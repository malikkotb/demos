!function(){"use strict";const e={webgl2:!1,webgl1:!1,detected:!1,detect(){if(this.detected)return;const e=document.createElement("canvas");try{e.getContext("webgl2")&&(this.webgl2=!0,this.webgl1=!0)}catch(e){}if(!this.webgl2)try{(e.getContext("webgl")||e.getContext("experimental-webgl"))&&(this.webgl1=!0)}catch(e){}this.detected=!0},getSupported(){return this.detect(),this.webgl2?"webgl2":!!this.webgl1&&"webgl"}};let n=null,o=0,t=new Map,i=null,l=!1,a=null,s=null,r=0,c=1e3/60,u=!0,f=[],d=!1,m=null;function v(){const e=navigator.userAgent;return/^((?!chrome|android).)*safari/i.test(e)}const p="\n    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n    float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                         -0.577350269189626, 0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v - i + dot(i, C.xx);\n      vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n      vec4 x12 = x0.xyxy + C.xxzz;\n      x12.xy -= i1;\n      i = mod289(i);\n      vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n      m = m*m; m = m*m;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n      vec3 g;\n      g.x = a0.x * x0.x + h.x * x0.y;\n      g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n      return 130.0 * dot(m, g);\n    }\n\n    float fbm(vec2 p, int octaves) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 1.0;\n      for (int i = 0; i < 6; i++) {\n        if (i >= octaves) break;\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n      }\n      return value;\n    }\n  ",h=`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform vec2 uResolution;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n\n    void main() {\n      vUv = uv;\n\n      vec3 pos = position;\n\n      float t = uTime * uFoldSpeed;\n\n      float noise1 = snoise(uv * uFoldScale * 2.0 + t * 0.3) * 0.5;\n      float noise2 = snoise(uv * uFoldScale * 4.0 - t * 0.2) * 0.25;\n      float noise3 = snoise(uv * uFoldScale * 8.0 + t * 0.1) * 0.125;\n\n      float rawDisp = (noise1 + noise2 + noise3) * uFoldIntensity;\n      float displacement = rawDisp * 0.00015;\n\n      vec2 mousePos = uMouse;\n      float mouseDist = distance(uv, mousePos);\n      float mouseInfluence = 1.0 - smoothstep(0.0, uMouseRadius, mouseDist);\n      float rawMouseDisp = mouseInfluence * uReactiveStrength * 0.5;\n      displacement += rawMouseDisp * 0.5;\n\n      pos.z += displacement;\n\n      vDisplacement = displacement;\n      vPosition = pos;\n\n      float eps = 0.01;\n      vec2 uvPlusX = uv + vec2(eps, 0.0);\n      vec2 uvPlusY = uv + vec2(0.0, eps);\n      \n      float noise1x = snoise(uvPlusX * uFoldScale * 2.0 + t * 0.3) * 0.5;\n      float noise2x = snoise(uvPlusX * uFoldScale * 4.0 - t * 0.2) * 0.25;\n      float noise3x = snoise(uvPlusX * uFoldScale * 8.0 + t * 0.1) * 0.125;\n      \n      float noise1y = snoise(uvPlusY * uFoldScale * 2.0 + t * 0.3) * 0.5;\n      float noise2y = snoise(uvPlusY * uFoldScale * 4.0 - t * 0.2) * 0.25;\n      float noise3y = snoise(uvPlusY * uFoldScale * 8.0 + t * 0.1) * 0.125;\n      \n      float dx = ((noise1x + noise2x + noise3x) - (noise1 + noise2 + noise3)) * uFoldIntensity;\n      float dy = ((noise1y + noise2y + noise3y) - (noise1 + noise2 + noise3)) * uFoldIntensity;\n\n      vec3 tangent = normalize(vec3(eps, 0.0, dx));\n      vec3 bitangent = normalize(vec3(0.0, eps, dy));\n      vNormal = normalize(cross(tangent, bitangent));\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n    }\n  `,g={aurora:{vertex:h,fragment:`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uMouseVelocity;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[7];\n    uniform float uColorBlend;\n    uniform float uColorBalance[7];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uScrollOffset;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform float uClickOffset;\n    uniform vec2 uLastClickPos;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n\n    float caustic(vec2 uv, float t, vec2 dir) {\n      float c = 0.0;\n      c += sin(uv.x * 2.0 + t * 0.4 * dir.x) * sin(uv.y * 1.8 - t * 0.3 * dir.y);\n      c += sin(uv.x * 1.5 - t * 0.25 * dir.x + uv.y * 2.2) * 0.6;\n      c += sin((uv.x * dir.x + uv.y * dir.y) * 1.8 + t * 0.35) * 0.4;\n      \n      return c * 0.3 + 0.5;\n    }\n    \n    vec3 rainbowSpectrum(float phase, vec3 colors[7], float balance[7], float blendSharpness) {\n      float index = phase * 7.0;\n      float blend = fract(index);\n      int i1 = int(floor(index)) % 7;\n      int i2 = (i1 + 1) % 7;\n      \n      if (blendSharpness < 0.1) {\n        blend = blend < 0.5 ? 0.0 : 1.0;\n      } else if (blendSharpness < 0.25) {\n        blend = smoothstep(0.3, 0.7, blend);\n      } else {\n        blend = blend * blend * (3.0 - 2.0 * blend);\n      }\n      \n      return mix(\n        colors[i1] * balance[i1],\n        colors[i2] * balance[i2],\n        blend\n      );\n    }\n\n    void main() {\n      vec2 uv = vUv;\n      float aspect = uResolution.x / uResolution.y;\n      \n      float t = uTime * uSpeed * 0.15;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, 1.0);\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, -1.0);\n      else if (uDirection == 3.0) dirOffset = vec2(-1.0, 0.0);\n      else if (uDirection == 4.0) dirOffset = vec2(1.0, 0.0);\n\n      vec2 mousePos = uMouse;\n      float mouseDist = distance(uv, mousePos);\n      float mouseInfluence = smoothstep(uMouseRadius * 2.0, 0.0, mouseDist) * uReactiveStrength;\n      \n      vec2 displaceOffset = uDisplacement * 0.15;\n      \n      float scrollY = uScrollOffset;\n\n      float blendSharpness = uColorBlend == 1.0 ? 0.15 : (uColorBlend == 2.0 ? 0.05 : 0.35);\n\n      // ---------------------------------------------\n      // Create flowing caustic light patterns\n      // ---------------------------------------------\n      \n      float clickInfluence = smoothstep(0.9, 0.0, distance(uv, uLastClickPos));\n      float tWithOffset = t + uClickOffset * clickInfluence * 1.5;\n      \n      vec2 causticUV1 = uv * 1.5 * uFoldScale + vec2(tWithOffset * 0.3 * dirOffset.x, tWithOffset * 0.2 * dirOffset.y + scrollY * 0.3) + displaceOffset;\n      vec2 causticUV2 = uv * 2.2 * uFoldScale + vec2(-tWithOffset * 0.25 * dirOffset.x, tWithOffset * 0.35 * dirOffset.y + scrollY * 0.5) + displaceOffset * 0.7;\n      vec2 causticUV3 = uv * 0.8 * uFoldScale + vec2(tWithOffset * 0.15 * dirOffset.x, -tWithOffset * 0.2 * dirOffset.y + scrollY * 0.2) + displaceOffset * 1.2;\n      \n      float c1 = caustic(causticUV1, tWithOffset * 2.0, dirOffset);\n      float c2 = caustic(causticUV2 + vec2(50.0), tWithOffset * 1.5, dirOffset);\n      float c3 = caustic(causticUV3 + vec2(100.0), tWithOffset * 2.5, dirOffset);\n      \n      float noiseDistort = snoise(uv * 2.0 * uFoldScale + tWithOffset * 0.2) * 0.2;\n      \n      // ---------------------------------------------\n      // Aurora color dispersion\n      // ---------------------------------------------\n      \n      float phase1 = fract(c1 + noiseDistort + mouseInfluence * 0.5);\n      float phase2 = fract(c2 + noiseDistort * 0.8 - mouseInfluence * 0.3);\n      float phase3 = fract(c3 + noiseDistort * 0.6);\n      \n      vec3 color = uColors[0] * uColorBalance[0];\n      \n      float bgLuminance = dot(color, vec3(0.299, 0.587, 0.114));\n      bool isLightBg = bgLuminance > 0.5;\n      \n      vec3 spectrum[7];\n      float spectrumBalance[7];\n      for (int i = 0; i < 7; i++) {\n        spectrum[i] = uColors[i];\n        spectrumBalance[i] = uColorBalance[i];\n      }\n      \n      vec3 rainbow1 = rainbowSpectrum(phase1, spectrum, spectrumBalance, blendSharpness);\n      float intensity1 = c1 * uFoldIntensity;\n      \n      if (isLightBg) {\n        color = mix(color, rainbow1, intensity1 * 0.65);\n      } else {\n        color = mix(color, color + rainbow1 * 0.7, intensity1 * 0.6);\n      }\n      \n      vec3 rainbow2 = rainbowSpectrum(phase2, spectrum, spectrumBalance, blendSharpness);\n      float intensity2 = c2 * uFoldIntensity * 0.7;\n      \n      if (isLightBg) {\n        color = mix(color, rainbow2, intensity2 * 0.45);\n      } else {\n        color = mix(color, color + rainbow2 * 0.6, intensity2 * 0.4);\n      }\n      \n      vec3 rainbow3 = rainbowSpectrum(phase3, spectrum, spectrumBalance, blendSharpness);\n      float intensity3 = c3 * uFoldIntensity * 0.5;\n      \n      if (isLightBg) {\n        color = mix(color, rainbow3, intensity3 * 0.3);\n      } else {\n        color = mix(color, color + rainbow3 * 0.5, intensity3 * 0.25);\n      }\n      \n      float softAurora = (c1 * c2 * c3) * uFoldIntensity;\n      vec3 auroraColor = mix(rainbow1, rainbow2, 0.5);\n      color += auroraColor * softAurora * 0.2;\n\n      // ---------------------------------------------\n      // Bright hotspots where light converges\n      // ---------------------------------------------\n      if (uRimLight > 0.5) {\n        float convergence = c1 * c2 * c3;\n        float hotspot = smoothstep(0.15, 0.35, convergence) * uRimIntensity;\n        color += uRimColor * hotspot * 0.8;\n        \n        float mouseAurora = smoothstep(uMouseRadius, 0.0, mouseDist) * uReactiveStrength * 0.5;\n        color += uRimColor * mouseAurora;\n      }\n\n      // ---------------------------------------------\n      // Glassy depth effect\n      // ---------------------------------------------\n      float depth = vDisplacement * uFoldIntensity;\n      color *= 0.95 + depth * 0.15;\n\n\n      // ---------------------------------------------\n      // Subtle grain for texture\n      // ---------------------------------------------\n      float grain = (snoise(uv * 400.0 + t * 5.0) - 0.5) * uGrain;\n      color += grain;\n\n      color = clamp(color, 0.0, 1.0);\n\n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  `},nebula:{vertex:h,fragment:`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uMouseVelocity;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[4];\n    uniform float uColorBlend;\n    uniform float uColorBalance[4];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uScrollOffset;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n\n    float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n    }\n\n    float fbm(vec2 p) {\n        float v = 0.0;\n        float a = 0.5;\n        mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n        for (int i = 0; i < 5; ++i) {\n            v += a * snoise(p);\n            p = rot * p * 2.0 + vec2(100.0);\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    float fbmDetail(vec2 p, float detail) {\n        float v = 0.0;\n        float a = 0.5;\n        float totalAmp = 0.0;\n        mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n        \n        float octaveFloat = 2.0 + detail * 1.0;\n        int maxOctaves = int(ceil(octaveFloat));\n        float lastOctaveWeight = fract(octaveFloat);\n        \n        float persistence = 0.45 + detail * 0.02;\n        \n        for (int i = 0; i < 7; ++i) {\n            if (i >= maxOctaves) break;\n            \n            float weight = (i == maxOctaves - 1) ? lastOctaveWeight : 1.0;\n            v += a * snoise(p) * weight;\n            totalAmp += a * weight;\n            \n            p = rot * p * 2.0 + vec2(100.0);\n            a *= persistence;\n        }\n        return v / max(totalAmp, 0.001);\n    }\n\n    void main() {\n      vec2 uv = vUv * 0.8; \n      float aspect = uResolution.x / uResolution.y;\n      uv.x *= aspect;\n\n      float t = uTime * uSpeed * uFoldSpeed * 0.02;\n      \n      float cloudDetail = uFoldScale;\n      float rawRichness = uFoldIntensity * 2.0;\n      float cloudRichness = 0.5 + tanh(rawRichness) * 1.5;\n      \n      // ---------------------------------------------\n      // MOUSE DISPLACEMENT - Persistent push effect\n      // ---------------------------------------------\n      vec2 toMouse = vUv - uMouse;\n      float mouseDist = length(toMouse);\n      \n      vec2 displaceOffset = uDisplacement * 0.02;\n      \n      float pushRadius = 0.35;\n      float pushStrength = smoothstep(pushRadius, 0.0, mouseDist);\n      vec2 mouseOffset = (uMouse - vec2(0.5)) * 2.0;\n      \n      vec2 proximityPush = mouseOffset * pushStrength * 0.15;\n      \n      float pulseWave = uPulse * (1.0 - smoothstep(0.0, 0.5, mouseDist - uPulse * 0.8));\n      vec2 pulsePush = mouseOffset * pulseWave * 0.25;\n      \n      vec2 totalDisplace = displaceOffset + proximityPush + pulsePush;\n      \n      float scrollY = uScrollOffset;\n\n      // ---------------------------------------------\n      // Direction-based time offset\n      // ---------------------------------------------\n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, 1.0);      // up\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, -1.0); // down\n      else if (uDirection == 3.0) dirOffset = vec2(-1.0, 0.0); // left\n      else if (uDirection == 4.0) dirOffset = vec2(1.0, 0.0);  // right\n\n      // ---------------------------------------------\n      // Color blending helper\n      // ---------------------------------------------\n      float blendSharpness = uColorBlend == 1.0 ? 0.1 : (uColorBlend == 2.0 ? 0.02 : 0.35);\n\n      // ---------------------------------------------\n      // Nebula Layers with displacement\n      // ---------------------------------------------\n      \n      vec3 color = uColors[0] * uColorBalance[0];\n      \n      vec2 uv0 = uv * 0.25 + vec2(t * 0.06 * dirOffset.x, -t * 0.03 * dirOffset.y + scrollY * 0.2);\n      float n0 = fbmDetail(uv0 + vec2(-100.0, 50.0), cloudDetail);\n      n0 = n0 * 0.5 + 0.5;\n      float mask0 = smoothstep(0.25, 0.25 + blendSharpness, n0);\n      color += uColors[2] * uColorBalance[2] * 0.15 * mask0 * cloudRichness;\n      \n      vec2 uv1 = uv * 0.8 + vec2(t * 0.5 * dirOffset.x, t * 0.2 * dirOffset.y + scrollY * 0.4) + totalDisplace * 0.3;\n      float n1 = fbmDetail(uv1, cloudDetail);\n      n1 = n1 * 0.5 + 0.5;\n      float mask1 = smoothstep(0.4, 0.4 + blendSharpness, n1);\n      color += uColors[1] * uColorBalance[1] * mask1 * 0.35 * cloudRichness;\n\n      vec2 uv2 = uv * 1.5 + vec2(-t * 0.3 * dirOffset.x, t * 0.4 * dirOffset.y + scrollY * 0.6) + totalDisplace * 0.6;\n      float n2 = fbmDetail(uv2 + vec2(10.0), cloudDetail);\n      n2 = n2 * 0.5 + 0.5;\n      float mask2 = smoothstep(0.45, 0.45 + blendSharpness * 0.7, n2);\n      color += uColors[2] * uColorBalance[2] * mask2 * 0.4 * cloudRichness;\n\n      vec2 uv3 = uv * 3.0 + vec2(t * 0.2 * dirOffset.x, -t * 0.5 * dirOffset.y + scrollY * 0.8) + totalDisplace * 1.0;\n      float n3 = fbmDetail(uv3 + vec2(20.0), cloudDetail);\n      n3 = n3 * 0.5 + 0.5;\n      float mask3 = smoothstep(0.55, 0.55 + blendSharpness * 0.7, n3);\n      color += uColors[3] * uColorBalance[3] * mask3 * 0.4 * cloudRichness;\n\n      // ---------------------------------------------\n      // Dark Dust Lanes - displaced (softened)\n      // ---------------------------------------------\n      vec2 uvDust = uv * 2.0 + vec2(t * 0.1, scrollY * 0.5) + totalDisplace * 0.5;\n      float dust = fbmDetail(uvDust, cloudDetail * 0.5);\n      dust = dust * 0.5 + 0.5;\n      float dustMask = smoothstep(0.4, 0.7, dust) * 0.3;\n      color = mix(color, uColors[0], dustMask);\n\n      // ---------------------------------------------\n      // Pulse aurora effect\n      // ---------------------------------------------\n      if (uPulse > 0.01) {\n        float pulseAurora = uPulse * smoothstep(0.4, 0.0, abs(mouseDist - uPulse * 0.6));\n        color += uColors[3] * pulseAurora * 0.5;\n      }\n\n      // ---------------------------------------------\n      // Rim Aurora - adds aurora to bright areas (controlled by uRimLight toggle)\n      // ---------------------------------------------\n      if (uRimLight > 0.5) {\n        float luminance = dot(color, vec3(0.299, 0.587, 0.114));\n        float auroraThreshold = 1.0 - uRimFalloff * 0.15;\n        float aurora = smoothstep(auroraThreshold, auroraThreshold + 0.3, luminance);\n        vec3 rimContribution = uRimColor * aurora * uRimIntensity * 2.0;\n        rimContribution += uRimColor * luminance * uRimIntensity * 0.3;\n        color += rimContribution;\n      }\n\n      // ---------------------------------------------\n      // Finishing\n      // ---------------------------------------------\n      float grain = (hash(vUv * 90.0 + uTime) - 0.5) * uGrain;\n      color += grain;\n      \n      color = pow(color, vec3(1.3));\n\n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n\n      gl_FragColor = vec4(clamp(color, 0.0, 1.0), alpha);\n    }\n  `},floral:{vertex:h,fragment:`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uMouseVelocity;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uLastClickPos;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[7];\n    uniform float uColorBlend;\n    uniform float uColorBalance[7];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform float uScrollOffset;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n\n    float petalShape(vec2 p, float angle, float size) {\n      float c = cos(angle);\n      float s = sin(angle);\n      vec2 rotP = vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n      \n      float dist = length(rotP);\n      \n      float angleFromCenter = atan(rotP.x, max(rotP.y, 0.001));\n      float curveFactor = 1.0 + sin(angleFromCenter * 1.5) * 0.2;\n      \n      float petalY = max(rotP.y, 0.0);\n      \n      float taper = 1.0 - (petalY / size);\n      float petalWidth = abs(rotP.x) * 1.2 * curveFactor * taper;\n      float petalLength = petalY * 0.5;\n      \n      float petal = 1.0 - smoothstep(size * 0.3, size * 0.6, petalWidth + petalLength);\n      \n      float tip = smoothstep(size * 1.6, size * 0.6, dist);\n      petal *= tip;\n      \n      petal = pow(petal, 1.8);\n      \n      return petal;\n    }\n    \n    float flowerPattern(vec2 uv, vec2 center, int petals, float rotation, float size) {\n      vec2 p = uv - center;\n      float dist = length(p);\n      \n      float pattern = 0.0;\n      float petalAngle = 6.28318 / float(petals);\n      \n      for(int i = 0; i < 6; i++) {\n        if(i >= petals) break;\n        float a = float(i) * petalAngle + rotation;\n        pattern = max(pattern, petalShape(p, a, size));\n      }\n      \n      float center_circle = 1.0 - smoothstep(size * 0.12, size * 0.22, dist);\n      pattern = max(pattern, center_circle);\n      \n      return pattern;\n    }\n    \n    float petalTexture(vec2 p, float time) {\n      float n1 = snoise(p * 6.0 + time * 0.1);\n      float n2 = snoise(p * 12.0 - time * 0.08);\n      return (n1 * 0.6 + n2 * 0.4) * 0.5 + 0.5;\n    }\n\n    void main() {\n      vec2 uv = vUv;\n      float aspect = uResolution.x / uResolution.y;\n      uv.x *= aspect;\n      \n      float t = uTime * uSpeed * uFoldSpeed * 0.5;\n      \n      float flowerScale = uFoldScale;\n      float flowerIntensity = uFoldIntensity;\n      \n      vec2 toMouse = vUv - uMouse;\n      float mouseDist = length(toMouse);\n      vec2 displaceOffset = uDisplacement * 0.02;\n      \n      float pushRadius = 0.4;\n      float pushStrength = smoothstep(pushRadius, 0.0, mouseDist) * uReactiveStrength;\n      vec2 mouseOffset = (uMouse - vec2(0.5)) * 2.0;\n      vec2 proximityPush = mouseOffset * pushStrength * 0.08;\n      \n      vec2 clickDisplace = vec2(0.0);\n      if (uPulse > 0.01) {\n        float clickDist = distance(vUv, uLastClickPos);\n        float expandProgress = 1.0 - uPulse;\n        \n        float angleToClick = atan(vUv.y - uLastClickPos.y, vUv.x - uLastClickPos.x);\n        float wavePattern = sin(angleToClick * 3.0 + expandProgress * 6.0) * 0.04 + \n                           sin(angleToClick * 5.0 - expandProgress * 9.0) * 0.03 +\n                           sin(angleToClick * 2.0 + expandProgress * 4.0) * 0.02;\n        float waveRadius = expandProgress * uMouseRadius * 3.0 * (1.0 + wavePattern);\n        float waveThickness = uMouseRadius * 1.2;\n        float wave = smoothstep(waveRadius + waveThickness, waveRadius, clickDist) * \n                     smoothstep(waveRadius - waveThickness * 0.5, waveRadius, clickDist);\n        float clickInfluence = wave * uPulse;\n        vec2 clickOffset = (uLastClickPos - vec2(0.5)) * 2.0;\n        clickDisplace = clickInfluence * clickOffset * 0.6;\n      }\n      \n      vec2 totalDisplace = displaceOffset + proximityPush + clickDisplace;\n      \n      float scrollY = uScrollOffset;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, 1.0);\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, -1.0);\n      else if (uDirection == 3.0) dirOffset = vec2(1.0, 0.0);\n      else if (uDirection == 4.0) dirOffset = vec2(-1.0, 0.0);\n      \n      float blendSharpness = uColorBlend == 1.0 ? 0.15 : (uColorBlend == 2.0 ? 0.05 : 0.35);\n      float edgePow = blendSharpness < 0.1 ? 3.0 : (blendSharpness < 0.25 ? 2.2 : 1.5);\n      \n      vec3 color = uColors[0] * uColorBalance[0] * 0.2;\n      \n      vec2 uv1 = uv * (1.5 / flowerScale) + vec2(t * 0.1 * dirOffset.x, t * 0.08 * dirOffset.y + scrollY * 0.3) + totalDisplace * 0.3;\n      vec2 tile1 = fract(uv1) - 0.5;\n      vec2 id1 = floor(uv1);\n      float hash1 = fract(sin(dot(id1, vec2(127.1, 311.7))) * 43758.5453);\n      float hash1b = fract(sin(dot(id1, vec2(269.5, 183.3))) * 43758.5453);\n      int petals1 = 6 + int(hash1 * 3.0);\n      float rotation1 = hash1 * 6.28318 + t * 0.15;\n      float sizeVar1 = 0.35 * (0.8 + hash1b * 0.4);\n      float flower1 = flowerPattern(tile1, vec2(0.0), petals1, rotation1, sizeVar1);\n      flower1 = pow(flower1, edgePow);\n      float texture1 = petalTexture(tile1, t);\n      color += uColors[1] * uColorBalance[1] * flower1 * (0.6 + texture1 * 0.3) * flowerIntensity;\n      \n      vec2 uv2 = uv * (2.2 / flowerScale) + vec2(-t * 0.12 * dirOffset.x, t * 0.1 * dirOffset.y + scrollY * 0.5) + totalDisplace * 0.5;\n      uv2 += vec2(0.5, 0.25);\n      vec2 tile2 = fract(uv2) - 0.5;\n      vec2 id2 = floor(uv2);\n      float hash2 = fract(sin(dot(id2, vec2(269.5, 183.3))) * 43758.5453);\n      float hash2b = fract(sin(dot(id2, vec2(419.2, 371.9))) * 43758.5453);\n      int petals2 = 5 + int(hash2 * 4.0);\n      float rotation2 = hash2 * 6.28318 - t * 0.18;\n      float sizeVar2 = 0.32 * (0.8 + hash2b * 0.4);\n      float flower2 = flowerPattern(tile2, vec2(0.0), petals2, rotation2, sizeVar2);\n      flower2 = pow(flower2, edgePow);\n      float texture2 = petalTexture(tile2, t * 1.1);\n      color += uColors[2] * uColorBalance[2] * flower2 * (0.65 + texture2 * 0.25) * flowerIntensity;\n      \n      vec2 uv3 = uv * (2.8 / flowerScale) + vec2(t * 0.08 * dirOffset.x, -t * 0.12 * dirOffset.y + scrollY * 0.7) + totalDisplace * 0.7;\n      vec2 tile3 = fract(uv3) - 0.5;\n      vec2 id3 = floor(uv3);\n      float hash3 = fract(sin(dot(id3, vec2(419.2, 371.9))) * 43758.5453);\n      float hash3b = fract(sin(dot(id3, vec2(541.3, 239.7))) * 43758.5453);\n      int petals3 = 6 + int(hash3 * 3.0);\n      float rotation3 = hash3 * 6.28318 + t * 0.22;\n      float sizeVar3 = 0.3 * (0.8 + hash3b * 0.4);\n      float flower3 = flowerPattern(tile3, vec2(0.0), petals3, rotation3, sizeVar3);\n      flower3 = pow(flower3, edgePow);\n      float texture3 = petalTexture(tile3, t * 0.9);\n      color += uColors[3] * uColorBalance[3] * flower3 * (0.7 + texture3 * 0.3) * flowerIntensity;\n      \n      vec2 uv4 = uv * (3.5 / flowerScale) + vec2(t * 0.15 * dirOffset.x, t * 0.1 * dirOffset.y + scrollY * 0.9) + totalDisplace;\n      uv4 += vec2(0.25, 0.5);\n      vec2 tile4 = fract(uv4) - 0.5;\n      vec2 id4 = floor(uv4);\n      float hash4 = fract(sin(dot(id4, vec2(541.3, 239.7))) * 43758.5453);\n      float hash4b = fract(sin(dot(id4, vec2(631.2, 152.4))) * 43758.5453);\n      int petals4 = 5 + int(hash4 * 3.0);\n      float rotation4 = hash4 * 6.28318 - t * 0.28;\n      float sizeVar4 = 0.28 * (0.8 + hash4b * 0.4);\n      float flower4 = flowerPattern(tile4, vec2(0.0), petals4, rotation4, sizeVar4);\n      flower4 = pow(flower4, edgePow);\n      float texture4 = petalTexture(tile4, t * 1.2);\n      color += uColors[4] * uColorBalance[4] * flower4 * (0.75 + texture4 * 0.25) * flowerIntensity;\n      color += uColors[5] * uColorBalance[5] * flower4 * (0.5 + texture4 * 0.2) * flowerIntensity;\n      color += uColors[6] * uColorBalance[6] * flower4 * (0.4 + texture4 * 0.15) * flowerIntensity;\n      \n      if (uRimLight > 0.5) {\n        float luminance = dot(color, vec3(0.299, 0.587, 0.114));\n        float rimThreshold = 1.0 - uRimFalloff * 0.1;\n        float rim = smoothstep(rimThreshold, rimThreshold + 0.2, luminance);\n        color += uRimColor * rim * uRimIntensity * 1.5;\n      }\n      \n      float grain = (fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * uGrain;\n      color += grain;\n      \n      color = pow(color, vec3(1.1));\n      \n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n\n      gl_FragColor = vec4(clamp(color, 0.0, 1.0), alpha);\n    }\n  `},oil:{vertex:h,fragment:`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[7];\n    uniform float uColorBlend;\n    uniform float uColorBalance[7];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform vec2 uDisplacement;\n    uniform float uScrollOffset;\n    uniform float uPulse;\n    uniform vec2 uLastClickPos;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n    \n    float floralNoise(vec2 p, float t) {\n      vec2 q = vec2(\n        fbm(p + vec2(0.0, 0.0), 4),\n        fbm(p + vec2(5.2, 1.3), 4)\n      );\n      \n      vec2 r = vec2(\n        fbm(p + 0.85*q + vec2(t, t*0.9), 4),\n        fbm(p + 0.85*q + vec2(t*0.8, -t) + vec2(8.3, 2.8), 4)\n      );\n      \n      return fbm(p + 0.85*r, 4);\n    }\n\n    void main() {\n      vec2 uv = vUv;\n      vec2 aspectUv = uv;\n      aspectUv.x *= uResolution.x / uResolution.y;\n\n      float t = uTime * uSpeed * uFoldSpeed * 0.1;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, -1.0);\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, 1.0);\n      else if (uDirection == 3.0) dirOffset = vec2(1.0, 0.0);\n      else if (uDirection == 4.0) dirOffset = vec2(-1.0, 0.0);\n      \n      // ---------------------------------------------\n      // Interaction & Displacement\n      // ---------------------------------------------\n      vec2 mousePos = uMouse;\n      float mouseDist = distance(uv, mousePos);\n      float mouseInfluence = smoothstep(uMouseRadius * 1.5, 0.0, mouseDist) * uReactiveStrength;\n      \n      float scaleFactor = uFoldScale * 0.1 + pow(uFoldScale, 2.0) * 0.2;\n      \n      vec2 flowUv = aspectUv * scaleFactor;\n      \n      flowUv += vec2(t * 0.15 * dirOffset.x, t * 0.15 * dirOffset.y);\n      flowUv.y += uScrollOffset * 0.08;\n      \n      flowUv += uDisplacement * 0.025;\n      vec2 toMouse = uv - mousePos;\n      float pushDist = length(toMouse);\n      float pushFalloff = smoothstep(0.0, uMouseRadius * 0.3, pushDist);\n      float pushStrength = mouseInfluence * pushFalloff * 0.12;\n      if (pushDist > 0.001) {\n        vec2 pushDir = toMouse / pushDist;\n        flowUv += pushDir * pushStrength;\n      }\n\n      // ---------------------------------------------\n      // Height Field & Normals\n      // ---------------------------------------------\n      float h = floralNoise(flowUv, t);\n      \n      float clickDist = distance(uv, uLastClickPos);\n      float ripple = sin(clickDist * 12.0 - uPulse * 10.0) * 0.5 + 0.5;\n      ripple *= smoothstep(0.8, 0.0, clickDist);\n      ripple *= smoothstep(0.0, 0.2, uPulse) * smoothstep(1.0, 0.6, uPulse);\n      h += ripple * 0.6;\n      \n      float normalStrength = (3.5 + uFoldIntensity * 8.0) / max(scaleFactor, 0.001);\n      vec2 dxy = vec2(dFdx(h), dFdy(h)) * normalStrength;\n      dxy = mix(dxy, vec2(0.0), 0.08);\n      vec3 normal = normalize(vec3(-dxy.x, -dxy.y, 1.0));\n\n      // ---------------------------------------------\n      // Lighting Model (Oillic)\n      // ---------------------------------------------\n      vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n      vec3 lightDir = normalize(vec3(-0.5, 0.5, 1.0));\n      vec3 halfDir = normalize(lightDir + viewDir);\n      \n      float NdotH = max(0.0, dot(normal, halfDir));\n      float spec = pow(NdotH, 30.0);\n      \n      float specSoft = pow(NdotH, 4.0);\n      \n      float fresnel = pow(1.0 - max(0.0, dot(normal, viewDir)), 2.0);\n\n      // ---------------------------------------------\n      // Color Composition\n      // ---------------------------------------------\n      float blendSharpness = uColorBlend == 1.0 ? 0.15 : (uColorBlend == 2.0 ? 0.05 : 0.35);\n      \n      vec3 baseColor = uColors[0] * uColorBalance[0];\n      \n      vec3 refDir = reflect(-viewDir, normal);\n      float envMap = snoise(refDir.xy * 2.0) * 0.5 + 0.5;\n      \n      float sharpPow = blendSharpness < 0.1 ? 6.0 : (blendSharpness < 0.25 ? 2.5 : 1.0);\n      float envMapSharp = pow(envMap, sharpPow);\n\n      if (blendSharpness < 0.1) {\n        envMapSharp = envMapSharp > 0.5 ? 1.0 : 0.0;\n      }\n      \n      vec3 envColor = mix(\n        uColors[1] * uColorBalance[1], \n        uColors[2] * uColorBalance[2], \n        envMapSharp\n      );\n      \n      vec3 finalColor = baseColor;\n      \n      finalColor = mix(finalColor, envColor, specSoft * 0.6);\n      \n      finalColor += envColor * fresnel * 0.8;\n      \n      finalColor += vec3(1.0) * spec * 0.8;\n      \n      if (length(uColors[3]) > 0.1) {\n        finalColor += uColors[3] * uColorBalance[3] * specSoft * 0.4;\n      }\n      \n      // ---------------------------------------------\n      // Chromatic Edge Highlights (using user colors)\n      // ---------------------------------------------\n      float chromatic = dot(normal, vec3(1.0, 0.0, 0.0));\n      vec3 edgeColor = vec3(0.0);\n      \n      edgeColor += uColors[1] * uColorBalance[1] * smoothstep(0.2, 0.6, chromatic);\n      edgeColor += uColors[2] * uColorBalance[2] * smoothstep(0.2, 0.6, -chromatic);\n      \n      finalColor += edgeColor * fresnel * uRimIntensity * 0.5;\n\n      // ---------------------------------------------\n      // Rim Light (User Controlled)\n      // ---------------------------------------------\n      if (uRimLight > 0.5) {\n        float heightPeaks = smoothstep(0.6, 0.8, h * 0.5 + 0.5);\n        float rim = heightPeaks * uRimIntensity;\n        finalColor += uRimColor * rim;\n      }\n\n      // ---------------------------------------------\n      // Grain & Dithering\n      // ---------------------------------------------\n      float grain = (snoise(uv * 1000.0 + t * 10.0) - 0.5) * uGrain;\n      finalColor += grain;\n      \n      finalColor = pow(finalColor, vec3(1.1));\n\n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n      gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), alpha);\n    }\n  `},diva:{vertex:h,fragment:`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uMouseVelocity;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uLastClickPos;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[7];\n    uniform float uColorBlend;\n    uniform float uColorBalance[7];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform float uScrollOffset;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n\n    float divaFlow(vec2 uv, float t, vec2 dir) {\n      float flow = 0.0;\n      flow += sin(uv.x * 3.0 + t * 0.5 * dir.x) * sin(uv.y * 2.5 - t * 0.4 * dir.y);\n      flow += sin(uv.x * 2.0 - t * 0.3 * dir.x + uv.y * 3.0) * 0.7;\n      flow += sin((uv.x * dir.x + uv.y * dir.y) * 2.5 + t * 0.4) * 0.5;\n      return flow * 0.3 + 0.5;\n    }\n    \n    vec3 rainbowSpectrum(float phase, vec3 colors[7], float balance[7], float blendSharpness) {\n      float index = phase * 7.0;\n      float blend = fract(index);\n      int i1 = int(floor(index)) % 7;\n      int i2 = (i1 + 1) % 7;\n      \n      if (blendSharpness < 0.1) {\n        blend = blend > 0.5 ? 1.0 : 0.0;\n      } else if (blendSharpness < 0.25) {\n        blend = blend * blend * blend * (blend * (blend * 6.0 - 15.0) + 10.0);\n      } else {\n        blend = blend * blend * (3.0 - 2.0 * blend);\n      }\n      \n      return mix(\n        colors[i1] * balance[i1],\n        colors[i2] * balance[i2],\n        blend\n      );\n    }\n\n    void main() {\n      vec2 uv = vUv;\n      float aspect = uResolution.x / uResolution.y;\n      \n      float t = uTime * uSpeed * uFoldSpeed * 0.15;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, 1.0);      // up\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, -1.0); // down\n      else if (uDirection == 3.0) dirOffset = vec2(-1.0, 0.0); // left\n      else if (uDirection == 4.0) dirOffset = vec2(1.0, 0.0);  // right\n\n      vec2 mousePos = uMouse;\n      float mouseDist = distance(uv, mousePos);\n      float mouseInfluence = smoothstep(uMouseRadius * 2.0, 0.0, mouseDist) * uReactiveStrength;\n      \n      vec2 displaceOffset = uDisplacement * 0.15;\n      float scrollY = uScrollOffset;\n\n      // ---------------------------------------------\n      // Create flowing diva patterns\n      // ---------------------------------------------\n      \n      vec2 flowUV1 = uv * 1.8 * uFoldScale + vec2(t * 0.3 * dirOffset.x, t * 0.25 * dirOffset.y + scrollY * 0.3) + displaceOffset;\n      vec2 flowUV2 = uv * 2.5 * uFoldScale + vec2(-t * 0.25 * dirOffset.x, t * 0.35 * dirOffset.y + scrollY * 0.5) + displaceOffset * 0.7;\n      vec2 flowUV3 = uv * 1.2 * uFoldScale + vec2(t * 0.2 * dirOffset.x, -t * 0.2 * dirOffset.y + scrollY * 0.2) + displaceOffset * 1.2;\n      \n      float flow1 = divaFlow(flowUV1, t * 2.0, dirOffset);\n      float flow2 = divaFlow(flowUV2 + vec2(50.0), t * 1.8, dirOffset);\n      float flow3 = divaFlow(flowUV3 + vec2(100.0), t * 2.2, dirOffset);\n      \n      float noiseDistort = snoise(uv * 2.0 * uFoldScale + t * 0.2) * 0.2;\n      \n      // ---------------------------------------------\n      // Diva color dispersion\n      // ---------------------------------------------\n      \n      float blendSharpness = uColorBlend == 1.0 ? 0.15 : (uColorBlend == 2.0 ? 0.05 : 0.35);\n      \n      float phase1 = fract(flow1 + noiseDistort + mouseInfluence * 0.5);\n      float phase2 = fract(flow2 + noiseDistort * 0.8 - mouseInfluence * 0.3);\n      float phase3 = fract(flow3 + noiseDistort * 0.6);\n      \n      vec3 color = uColors[0] * uColorBalance[0];\n      float bgLuminance = dot(color, vec3(0.299, 0.587, 0.114));\n      bool isLightBg = bgLuminance > 0.5;\n      \n      vec3 rainbow1 = rainbowSpectrum(phase1, uColors, uColorBalance, blendSharpness);\n      float intensity1 = flow1 * uFoldIntensity;\n      \n      if (isLightBg) {\n        color = mix(color, rainbow1, intensity1 * 0.7);\n      } else {\n        color = mix(color, color + rainbow1 * 0.75, intensity1 * 0.65);\n      }\n      \n      vec3 rainbow2 = rainbowSpectrum(phase2, uColors, uColorBalance, blendSharpness);\n      float intensity2 = flow2 * uFoldIntensity * 0.75;\n      \n      if (isLightBg) {\n        color = mix(color, rainbow2, intensity2 * 0.5);\n      } else {\n        color = mix(color, color + rainbow2 * 0.65, intensity2 * 0.45);\n      }\n      \n      vec3 rainbow3 = rainbowSpectrum(phase3, uColors, uColorBalance, blendSharpness);\n      float intensity3 = flow3 * uFoldIntensity * 0.55;\n      \n      if (isLightBg) {\n        color = mix(color, rainbow3, intensity3 * 0.35);\n      } else {\n        color = mix(color, color + rainbow3 * 0.55, intensity3 * 0.3);\n      }\n      \n      // ---------------------------------------------\n      // Displacement depth\n      // ---------------------------------------------\n      float depthFactor = abs(vDisplacement) * uFoldIntensity * 0.4;\n      color = mix(color, color * 1.15, depthFactor);\n      \n      if (mouseInfluence > 0.01) {\n        color += color * mouseInfluence * 0.25;\n      }\n      \n      if (uPulse > 0.01) {\n        float clickDist = distance(vUv, uLastClickPos);\n        float expandProgress = 1.0 - uPulse;\n        float waveRadius = expandProgress * uMouseRadius * 3.5;\n        float waveThickness = uMouseRadius * 0.8;\n        \n        float wave = smoothstep(waveRadius + waveThickness, waveRadius, clickDist) * \n                     smoothstep(waveRadius - waveThickness * 0.5, waveRadius, clickDist);\n        \n        float clickIntensity = wave * uPulse * 1.2;\n        color += color * clickIntensity;\n      }\n      \n      // ---------------------------------------------\n      // Rim lighting\n      // ---------------------------------------------\n      if (uRimLight > 0.5) {\n        float edgeFactor = 1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0)));\n        edgeFactor = pow(edgeFactor, uRimFalloff);\n        color += uRimColor * edgeFactor * uRimIntensity;\n      }\n      \n      // ---------------------------------------------\n      // Grain\n      // ---------------------------------------------\n      float grain = (snoise(uv * 1000.0 + t * 10.0) - 0.5) * uGrain;\n      color += grain;\n      \n      color = pow(color, vec3(1.1));\n\n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n\n      gl_FragColor = vec4(clamp(color, 0.0, 1.0), alpha);\n    }\n  `},pixel:{vertex:h,fragment:"\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uMouseVelocity;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[7];\n    uniform float uColorBlend;\n    uniform float uColorBalance[7];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform float uScrollOffset;\n    uniform float uScrollVelocity;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    float Bayer2(vec2 a) {\n      a = floor(a);\n      return fract(a.x / 2.0 + a.y * a.y * 0.75);\n    }\n    #define Bayer4(a) (Bayer2(0.5 * (a)) * 0.25 + Bayer2(a))\n    #define Bayer8(a) (Bayer4(0.5 * (a)) * 0.25 + Bayer2(a))\n\n    float hash11(float n) { return fract(sin(n) * 43758.5453); }\n    \n    float hash12(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n    }\n\n    float vnoise(vec3 p) {\n      vec3 ip = floor(p);\n      vec3 fp = fract(p);\n      float n000 = hash11(dot(ip + vec3(0.0, 0.0, 0.0), vec3(1.0, 57.0, 113.0)));\n      float n100 = hash11(dot(ip + vec3(1.0, 0.0, 0.0), vec3(1.0, 57.0, 113.0)));\n      float n010 = hash11(dot(ip + vec3(0.0, 1.0, 0.0), vec3(1.0, 57.0, 113.0)));\n      float n110 = hash11(dot(ip + vec3(1.0, 1.0, 0.0), vec3(1.0, 57.0, 113.0)));\n      float n001 = hash11(dot(ip + vec3(0.0, 0.0, 1.0), vec3(1.0, 57.0, 113.0)));\n      float n101 = hash11(dot(ip + vec3(1.0, 0.0, 1.0), vec3(1.0, 57.0, 113.0)));\n      float n011 = hash11(dot(ip + vec3(0.0, 1.0, 1.0), vec3(1.0, 57.0, 113.0)));\n      float n111 = hash11(dot(ip + vec3(1.0, 1.0, 1.0), vec3(1.0, 57.0, 113.0)));\n      vec3 w = fp * fp * fp * (fp * (fp * 6.0 - 15.0) + 10.0);\n      float x00 = mix(n000, n100, w.x);\n      float x10 = mix(n010, n110, w.x);\n      float x01 = mix(n001, n101, w.x);\n      float x11 = mix(n011, n111, w.x);\n      float y0 = mix(x00, x10, w.y);\n      float y1 = mix(x01, x11, w.y);\n      return mix(y0, y1, w.z) * 2.0 - 1.0;\n    }\n\n    float fbm2(vec2 uv, float t) {\n      vec3 p = vec3(uv * uFoldScale, t);\n      float amp = 1.0;\n      float freq = 1.0;\n      float sum = 1.0;\n      for (int i = 0; i < 5; ++i) {\n        sum += amp * vnoise(p * freq);\n        freq *= 1.25;\n        amp *= 1.0;\n      }\n      return sum * 0.5 + 0.5;\n    }\n\n    float maskCircle(vec2 p, float cov) {\n      float r = sqrt(cov) * 0.25;\n      float d = length(p - 0.5) - r;\n      float aa = 0.5 * fwidth(d);\n      return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));\n    }\n\n    float maskTriangle(vec2 p, vec2 id, float cov) {\n      bool flip = mod(id.x + id.y, 2.0) > 0.5;\n      if (flip) p.x = 1.0 - p.x;\n      float r = sqrt(cov);\n      float d = p.y - r * (1.0 - p.x);\n      float aa = fwidth(d);\n      return cov * clamp(0.5 - d / aa, 0.0, 1.0);\n    }\n\n    float maskDiamond(vec2 p, float cov) {\n      float r = sqrt(cov) * 0.564;\n      return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);\n    }\n\n    void main() {\n      float t = uTime * uSpeed * uFoldSpeed * 0.05;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, -1.0);\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, 1.0);\n      else if (uDirection == 3.0) dirOffset = vec2(1.0, 0.0);\n      else if (uDirection == 4.0) dirOffset = vec2(-1.0, 0.0);\n\n      float pixelSize = 3.0 + uFoldIntensity * 5.0;\n      \n      vec2 fragCoord = gl_FragCoord.xy;\n      float aspectRatio = uResolution.x / uResolution.y;\n\n      vec2 pixelId = floor(fragCoord / pixelSize);\n      vec2 pixelUV = fract(fragCoord / pixelSize);\n\n      float cellPixelSize = 8.0 * pixelSize;\n      vec2 cellId = floor(fragCoord / cellPixelSize);\n      vec2 cellCoord = cellId * cellPixelSize;\n      vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);\n      \n      uv += dirOffset * t * 0.5;\n      \n      uv.y += uScrollOffset * 0.02;\n      \n      uv += uDisplacement * 0.05;\n\n      float base = fbm2(uv, t);\n      base = base * 0.5 - 0.65;\n\n      float density = 0.5 + uRimFalloff * 0.1;\n      float feed = base + (density - 0.5) * 0.3;\n\n      vec2 mousePos = uMouse;\n      float mouseDist = distance(vUv, mousePos);\n      float mouseInfluence = smoothstep(uMouseRadius * 2.0, 0.0, mouseDist) * uReactiveStrength;\n      feed += mouseInfluence * 0.3;\n\n      if (uPulse > 0.01) {\n        vec2 mousePixelCoord = uMouse * uResolution;\n        float elapsed = uPulse * 2.0;\n        \n        float pixelDist = distance(fragCoord, mousePixelCoord);\n        \n        float maxRadiusPixels = uMouseRadius * min(uResolution.x, uResolution.y);\n        \n        float pixelRandom = hash12(pixelId);\n        \n        float randomExpansionFactor = 0.5 + pixelRandom * 1.0;\n        \n        float turnOnTime = (pixelDist / maxRadiusPixels) * 0.6 * randomExpansionFactor;\n        float isActive = step(turnOnTime, elapsed);\n        \n        float flickerStartTime = 0.8 + pixelRandom * 0.5;\n        float flickerDuration = 1.0;\n        float flickerProgress = clamp((elapsed - flickerStartTime) / flickerDuration, 0.0, 1.0);\n        \n        float timeFlicker = 1.0;\n        if (elapsed > flickerStartTime) {\n          float flickerSpeed = 20.0;\n          timeFlicker = mix(0.3, 1.0, hash12(pixelId + floor(uTime * flickerSpeed)));\n        }\n        \n        float intensity = (1.0 - flickerProgress) * timeFlicker;\n        \n        float distFalloff = exp(-pixelDist / (maxRadiusPixels * 0.3));\n        \n        float clickContribution = isActive * intensity * distFalloff * uReactiveStrength * 0.8;\n        feed += clickContribution;\n      }\n      \n      float bayer = Bayer8(fragCoord / pixelSize) - 0.5;\n      float bw = step(0.5, feed + bayer);\n\n      float h = hash12(floor(fragCoord / pixelSize));\n      float jitterScale = 1.0 + (h - 0.5) * uGrain * 10.0;\n      float coverage = bw * jitterScale;\n      \n      float M;\n      int shapeType = int(uColorBlend);\n      if (shapeType == 1) M = maskCircle(pixelUV, coverage);\n      else if (shapeType == 2) M = maskTriangle(pixelUV, pixelId, coverage);\n      else if (shapeType == 3) M = maskDiamond(pixelUV, coverage);\n      else M = coverage;\n\n      if (uRimIntensity > 0.0) {\n        vec2 norm = gl_FragCoord.xy / uResolution;\n        float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));\n        float fade = smoothstep(0.0, uRimIntensity * 0.5, edge);\n        M *= fade;\n      }\n\n      vec3 pixelColor = uColors[1] * uColorBalance[1];\n      \n      float colorVar = fbm2(uv * 0.5, t * 0.5);\n      vec3 secondaryColor = uColors[2] * uColorBalance[2];\n      pixelColor = mix(pixelColor, secondaryColor, colorVar * 0.3);\n      \n      vec3 accentColor = uColors[3] * uColorBalance[3];\n      float accentMix = mouseInfluence * 0.5 + smoothstep(0.6, 0.9, feed) * 0.3;\n      pixelColor = mix(pixelColor, accentColor, accentMix);\n      \n      if (uRimLight > 0.5) {\n        float rimMask = 1.0 - smoothstep(0.3, 0.7, feed);\n        pixelColor = mix(pixelColor, uRimColor, rimMask * 0.2);\n      }\n\n      vec3 bgColor = uColors[0] * uColorBalance[0];\n      vec3 finalColor = mix(bgColor, pixelColor, M);\n\n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n      \n      gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), alpha);\n    }\n  "},shimmer:{vertex:h,fragment:`\n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uMouseVelocity;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uResolution;\n    uniform vec3 uColors[7];\n    uniform float uColorBlend;\n    uniform float uColorBalance[7];\n    uniform float uDirection;\n    uniform float uSpeed;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform float uGrain;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform float uScrollOffset;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    varying float vDisplacement;\n\n    ${p}\n\n    vec3 smoothSpectrum(float phase, vec3 colors[7], float balance[7], float blendSharpness) {\n      float p = phase * 6.283185;\n      \n      float sharpnessMult = blendSharpness < 0.1 ? 4.0 : (blendSharpness < 0.25 ? 2.0 : 1.0);\n      \n      float w0 = max(0.0, cos(p - 0.0) * sharpnessMult * 0.5 + 0.5);\n      float w1 = max(0.0, cos(p - 0.898) * sharpnessMult * 0.5 + 0.5);\n      float w2 = max(0.0, cos(p - 1.795) * sharpnessMult * 0.5 + 0.5);\n      float w3 = max(0.0, cos(p - 2.693) * sharpnessMult * 0.5 + 0.5);\n      float w4 = max(0.0, cos(p - 3.590) * sharpnessMult * 0.5 + 0.5);\n      float w5 = max(0.0, cos(p - 4.488) * sharpnessMult * 0.5 + 0.5);\n      float w6 = max(0.0, cos(p - 5.385) * sharpnessMult * 0.5 + 0.5);\n      \n      if (blendSharpness < 0.1) {\n        w0 = w0 > 0.5 ? 1.0 : 0.0;\n        w1 = w1 > 0.5 ? 1.0 : 0.0;\n        w2 = w2 > 0.5 ? 1.0 : 0.0;\n        w3 = w3 > 0.5 ? 1.0 : 0.0;\n        w4 = w4 > 0.5 ? 1.0 : 0.0;\n        w5 = w5 > 0.5 ? 1.0 : 0.0;\n        w6 = w6 > 0.5 ? 1.0 : 0.0;\n      }\n      \n      float total = w0 + w1 + w2 + w3 + w4 + w5 + w6 + 0.001;\n      \n      vec3 result = \n        colors[0] * balance[0] * w0 +\n        colors[1] * balance[1] * w1 +\n        colors[2] * balance[2] * w2 +\n        colors[3] * balance[3] * w3 +\n        colors[4] * balance[4] * w4 +\n        colors[5] * balance[5] * w5 +\n        colors[6] * balance[6] * w6;\n      \n      return result / total;\n    }\n\n    void main() {\n      float mr = min(uResolution.x, uResolution.y);\n      vec2 uv = (vUv * 2.0 - 1.0) * uResolution.xy / mr;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, 1.0);      // up\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, -1.0); // down\n      else if (uDirection == 3.0) dirOffset = vec2(-1.0, 0.0); // left\n      else if (uDirection == 4.0) dirOffset = vec2(1.0, 0.0);  // right\n      \n      vec2 mousePos = uMouse;\n      float mouseDist = distance(vUv, mousePos);\n      float mouseInfluence = smoothstep(uMouseRadius * 2.0, 0.0, mouseDist) * uReactiveStrength;\n      uv += (mousePos - vec2(0.5)) * mouseInfluence * uFoldIntensity * 0.5;\n      \n      uv.y += uScrollOffset * 0.1;\n      \n      uv += uDisplacement * 0.08;\n\n      float t = uTime * 0.5 * uSpeed * uFoldSpeed;\n      \n      float blendSharpness = uColorBlend == 1.0 ? 0.15 : (uColorBlend == 2.0 ? 0.05 : 0.35);\n      \n      vec2 uvFlow = uv;\n      uvFlow.x += t * 0.2 * dirOffset.x;\n      uvFlow.y += t * 0.2 * dirOffset.y;\n      \n      float d = -t;\n      float a = 0.0;\n      \n      for (float i = 0.0; i < 8.0; ++i) {\n        a += cos(i - d - a * uvFlow.x);\n        d += sin(uvFlow.y * i + a);\n      }\n      d += t;\n      \n      vec2 uvScaled = uv * uFoldScale;\n      vec2 holoUV = uvScaled * vec2(d, a);\n      vec3 holoBase = vec3(\n        cos(holoUV.x) * 0.5 + 0.5,\n        cos(holoUV.y) * 0.5 + 0.5,\n        cos(a + d) * 0.5 + 0.5\n      );\n      holoBase = cos(holoBase * cos(vec3(d, a, 2.5)) * 0.4 + 0.5) * 0.5 + 0.5;\n      \n      vec3 bgColor = uColors[0] * uColorBalance[0];\n      float bgLuminance = dot(bgColor, vec3(0.299, 0.587, 0.114));\n      bool isLightBg = bgLuminance > 0.5;\n      \n      float phase = fract((d + a) * 0.08);\n      \n      vec3 userColor = smoothSpectrum(phase, uColors, uColorBalance, blendSharpness);\n      \n      vec3 finalColor;\n      float holoLum = dot(holoBase, vec3(0.33));\n      if (isLightBg) {\n        finalColor = mix(bgColor, userColor * holoBase, holoLum * uFoldIntensity * 0.7);\n      } else {\n        finalColor = bgColor + userColor * holoBase * uFoldIntensity * 0.6;\n      }\n      \n      if (mouseInfluence > 0.01) {\n        finalColor += userColor * mouseInfluence * 0.2;\n      }\n      \n      if (uPulse > 0.01) {\n        float pulseRing = sin(mouseDist * 12.0 - uPulse * 6.0) * 0.5 + 0.5;\n        pulseRing *= smoothstep(0.7, 0.0, mouseDist) * smoothstep(0.0, 0.25, uPulse) * smoothstep(1.0, 0.4, uPulse);\n        finalColor += userColor * pulseRing * 0.3;\n      }\n      \n      if (uRimLight > 0.5) {\n        float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));\n        float rimThreshold = 1.0 - uRimFalloff * 0.08;\n        float rim = smoothstep(rimThreshold, rimThreshold + 0.35, luminance);\n        finalColor += uRimColor * rim * uRimIntensity * 0.8;\n      }\n      \n      float depth = vDisplacement * uFoldIntensity;\n      finalColor *= 0.97 + depth * 0.08;\n      \n      float grain = (snoise(vUv * 300.0 + uTime * 3.0) - 0.5) * uGrain * 0.8;\n      finalColor += grain;\n      \n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n\n      gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), alpha);\n    }\n  `},komorebi:{vertex:h,fragment:"\n    precision highp float;\n    \n    uniform float uTime;\n    uniform vec2 uMouse;\n    uniform vec2 uResolution;\n    uniform vec2 uDisplacement;\n    uniform float uPulse;\n    uniform vec2 uLastClickPos;\n    uniform vec3 uColors[7];\n    uniform float uColorBalance[7];\n    uniform float uSpeed;\n    uniform float uFoldIntensity;\n    uniform float uFoldScale;\n    uniform float uFoldSpeed;\n    uniform float uDirection;\n    uniform float uGrain;\n    uniform float uReactiveStrength;\n    uniform float uMouseRadius;\n    uniform float uScrollOffset;\n    uniform float uRimLight;\n    uniform float uRimIntensity;\n    uniform vec3 uRimColor;\n    uniform float uRimFalloff;\n    uniform sampler2D uTextMask;\n    uniform float uUseTextMask;\n    uniform float uColorBlend;\n\n    varying vec2 vUv;\n\n    vec4 buf[8];\n    \n    float rand(vec2 c) {\n      return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n\n    mat3 rgb2yiq = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.211, -0.523, 0.312);\n    mat3 yiq2rgb = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.106, 1.703);\n\n    vec3 hueShiftRGB(vec3 col, float deg) {\n      vec3 yiq = rgb2yiq * col;\n      float rad = radians(deg);\n      float cosh = cos(rad), sinh = sin(rad);\n      vec3 yiqShift = vec3(yiq.x, yiq.y * cosh - yiq.z * sinh, yiq.y * sinh + yiq.z * cosh);\n      return clamp(yiq2rgb * yiqShift, 0.0, 1.0);\n    }\n\n    vec4 sigmoid(vec4 x) { return 1.0 / (1.0 + exp(-x)); }\n\n    vec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2) {\n      buf[6] = vec4(coordinate.x, coordinate.y, 0.3948333106474662 + in0, 0.36 + in1);\n      buf[7] = vec4(0.14 + in2, sqrt(coordinate.x * coordinate.x + coordinate.y * coordinate.y), 0.0, 0.0);\n      \n      buf[0] = mat4(vec4(6.5404263, -3.6126034, 0.7590882, -1.13613), vec4(2.4582713, 3.1660357, 1.2219609, 0.06276096), vec4(-5.478085, -6.159632, 1.8701609, -4.7742867), vec4(6.039214, -5.542865, -0.90925294, 3.251348)) * buf[6] + mat4(vec4(0.8473259, -5.722911, 3.975766, 1.6522468), vec4(-0.24321538, 0.5839259, -1.7661959, -5.350116), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * buf[7] + vec4(0.21808943, 1.1243913, -1.7969975, 5.0294676);\n      buf[1] = mat4(vec4(-3.3522482, -6.0612736, 0.55641043, -4.4719114), vec4(0.8631464, 1.7432913, 5.643898, 1.6106541), vec4(2.4941394, -3.5012043, 1.7184316, 6.357333), vec4(3.310376, 8.209261, 1.1355612, -1.165539)) * buf[6] + mat4(vec4(5.24046, -13.034365, 0.009859298, 15.870829), vec4(2.987511, 3.129433, -0.89023495, -1.6822904), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * buf[7] + vec4(-5.9457836, -6.573602, -0.8812491, 1.5436668);\n      buf[0] = sigmoid(buf[0]); buf[1] = sigmoid(buf[1]);\n      \n      buf[2] = mat4(vec4(-15.219568, 8.095543, -2.429353, -1.9381982), vec4(-5.951362, 4.3115187, 2.6393783, 1.274315), vec4(-7.3145227, 6.7297835, 5.2473326, 5.9411426), vec4(5.0796127, 8.979051, -1.7278991, -1.158976)) * buf[6] + mat4(vec4(-11.967154, -11.608155, 6.1486754, 11.237008), vec4(2.124141, -6.263192, -1.7050359, -0.7021966), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * buf[7] + vec4(-4.17164, -3.2281182, -4.576417, -3.6401186);\n      buf[3] = mat4(vec4(3.1832156, -13.738922, 1.879223, 3.233465), vec4(0.64300746, 12.768129, 1.9141049, 0.50990224), vec4(-0.049295485, 4.4807224, 1.4733979, 1.801449), vec4(5.0039253, 13.000481, 3.3991797, -4.5561905)) * buf[6] + mat4(vec4(-0.1285731, 7.720628, -3.1425676, 4.742367), vec4(0.6393625, 3.714393, -0.8108378, -0.39174938), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * buf[7] + vec4(-1.1811101, -21.621881, 0.7851888, 1.2329718);\n      buf[2] = sigmoid(buf[2]); buf[3] = sigmoid(buf[3]);\n      \n      buf[4] = mat4(vec4(5.214916, -7.183024, 2.7228765, 2.6592617), vec4(-5.601878, -25.3591, 4.067988, 0.4602802), vec4(-10.57759, 24.286327, 21.102104, 37.546658), vec4(4.3024497, -1.9625226, 2.3458803, -1.372816)) * buf[0] + mat4(vec4(-17.6526, -10.507558, 2.2587414, 12.462782), vec4(6.265566, -502.75443, -12.642513, 0.9112289), vec4(-10.983244, 20.741234, -9.701768, -0.7635988), vec4(5.383626, 1.4819539, -4.1911616, -4.8444734)) * buf[1] + mat4(vec4(12.785233, -16.345072, -0.39901125, 1.7955981), vec4(-30.48365, -1.8345358, 1.4542528, -1.1118771), vec4(19.872723, -7.337935, -42.941723, -98.52709), vec4(8.337645, -2.7312303, -2.2927687, -36.142323)) * buf[2] + mat4(vec4(-16.298317, 3.5471997, -0.44300047, -9.444417), vec4(57.5077, -35.609753, 16.163465, -4.1534753), vec4(-0.07470326, -3.8656476, -7.0901804, 3.1523974), vec4(-12.559385, -7.077619, 1.490437, -0.8211543)) * buf[3] + vec4(-7.67914, 15.927437, 1.3207729, -1.6686112);\n      buf[5] = mat4(vec4(-1.4109162, -0.372762, -3.770383, -21.367174), vec4(-6.2103205, -9.35908, 0.92529047, 8.82561), vec4(11.460242, -22.348068, 13.625772, -18.693201), vec4(-0.3429052, -3.9905605, -2.4626114, -0.45033523)) * buf[0] + mat4(vec4(7.3481627, -4.3661838, -6.3037653, -3.868115), vec4(1.5462853, 6.5488915, 1.9701879, -0.58291394), vec4(6.5858274, -2.2180402, 3.7127688, -1.3730392), vec4(-5.7973905, 10.134961, -2.3395722, -5.965605)) * buf[1] + mat4(vec4(-2.5132585, -6.6685553, -1.4029363, -0.16285264), vec4(-0.37908727, 0.53738135, 4.389061, -1.3024765), vec4(-0.70647055, 2.0111287, -5.1659346, -3.728635), vec4(-13.562562, 10.487719, -0.9173751, -2.6487076)) * buf[2] + mat4(vec4(-8.645013, 6.5546675, -6.3944063, -5.5933375), vec4(-0.57783127, -1.077275, 36.91025, 5.736769), vec4(14.283112, 3.7146652, 7.1452246, -4.5958776), vec4(2.7192075, 3.6021907, -4.366337, -2.3653464)) * buf[3] + vec4(-5.9000807, -4.329569, 1.2427121, 8.59503);\n      buf[4] = sigmoid(buf[4]); buf[5] = sigmoid(buf[5]);\n      \n      buf[6] = mat4(vec4(-1.61102, 0.7970257, 1.4675229, 0.20917463), vec4(-28.793737, -7.1390953, 1.5025433, 4.656581), vec4(-10.94861, 39.66238, 0.74318546, -10.095605), vec4(-0.7229728, -1.5483948, 0.7301322, 2.1687684)) * buf[0] + mat4(vec4(3.2547753, 21.489103, -1.0194173, -3.3100595), vec4(-3.7316632, -3.3792162, -7.223193, -0.23685838), vec4(13.1804495, 0.7916005, 5.338587, 5.687114), vec4(-4.167605, -17.798311, -6.815736, -1.6451967)) * buf[1] + mat4(vec4(0.604885, -7.800309, -7.213122, -2.741014), vec4(-3.522382, -0.12359311, -0.5258442, 0.43852118), vec4(9.6752825, -22.853785, 2.062431, 0.099892326), vec4(-4.3196306, -17.730087, 2.5184598, 5.30267)) * buf[2] + mat4(vec4(-6.545563, -15.790176, -6.0438633, -5.415399), vec4(-43.591583, 28.551912, -16.00161, 18.84728), vec4(4.212382, 8.394307, 3.0958717, 8.657522), vec4(-5.0237565, -4.450633, -4.4768, -5.5010443)) * buf[3] + mat4(vec4(1.6985557, -67.05806, 6.897715, 1.9004834), vec4(1.8680354, 2.3915145, 2.5231109, 4.081538), vec4(11.158006, 1.7294737, 2.0738268, 7.386411), vec4(-4.256034, -306.24686, 8.258898, -17.132736)) * buf[4] + mat4(vec4(1.6889864, -4.5852966, 3.8534803, -6.3482175), vec4(1.3543309, -1.2640043, 9.932754, 2.9079645), vec4(-5.2770967, 0.07150358, -0.13962056, 3.3269649), vec4(28.34703, -4.918278, 6.1044083, 4.085355)) * buf[5] + vec4(6.6818056, 12.522166, -3.7075126, -4.104386);\n      buf[7] = mat4(vec4(-8.265602, -4.7027016, 5.098234, 0.7509808), vec4(8.6507845, -17.15949, 16.51939, -8.884479), vec4(-4.036479, -2.3946867, -2.6055532, -1.9866527), vec4(-2.2167742, -1.8135649, -5.9759874, 4.8846445)) * buf[0] + mat4(vec4(6.7790847, 3.5076547, -2.8191125, -2.7028968), vec4(-5.743024, -0.27844876, 1.4958696, -5.0517144), vec4(13.122226, 15.735168, -2.9397483, -4.101023), vec4(-14.375265, -5.030483, -6.2599335, 2.9848232)) * buf[1] + mat4(vec4(4.0950394, -0.94011575, -5.674733, 4.755022), vec4(4.3809423, 4.8310084, 1.7425908, -3.437416), vec4(2.117492, 0.16342592, -104.56341, 16.949184), vec4(-5.22543, -2.994248, 3.8350096, -1.9364246)) * buf[2] + mat4(vec4(-5.900337, 1.7946124, -13.604192, -3.8060522), vec4(6.6583457, 31.911177, 25.164474, 91.81147), vec4(11.840538, 4.1503043, -0.7314397, 6.768467), vec4(-6.3967767, 4.034772, 6.1714606, -0.32874924)) * buf[3] + mat4(vec4(3.4992442, -196.91893, -8.923708, 2.8142626), vec4(3.4806502, -3.1846354, 5.1725626, 5.1804223), vec4(-2.4009497, 15.585794, 1.2863957, 2.0252278), vec4(-71.25271, -62.441242, -8.138444, 0.50670296)) * buf[4] + mat4(vec4(-12.291733, -11.176166, -7.3474145, 4.390294), vec4(10.805477, 5.6337385, -0.9385842, -4.7348723), vec4(-12.869276, -7.039391, 5.3029537, 7.5436664), vec4(1.4593618, 8.91898, 3.5101583, 5.840625)) * buf[5] + vec4(2.2415268, -6.705987, -0.98861027, -2.117676);\n      buf[6] = sigmoid(buf[6]); buf[7] = sigmoid(buf[7]);\n      \n      buf[0] = mat4(vec4(1.6794263, 1.3817469, 2.9625452, 0.0), vec4(-1.8834411, -1.4806935, -3.5924516, 0.0), vec4(-1.3279216, -1.0918057, -2.3124623, 0.0), vec4(0.2662234, 0.23235129, 0.44178495, 0.0)) * buf[0] + mat4(vec4(-0.6299101, -0.5945583, -0.9125601, 0.0), vec4(0.17828953, 0.18300213, 0.18182953, 0.0), vec4(-2.96544, -2.5819945, -4.9001055, 0.0), vec4(1.4195864, 1.1868085, 2.5176322, 0.0)) * buf[1] + mat4(vec4(-1.2584374, -1.0552157, -2.1688404, 0.0), vec4(-0.7200217, -0.52666044, -1.438251, 0.0), vec4(0.15345335, 0.15196142, 0.272854, 0.0), vec4(0.945728, 0.8861938, 1.2766753, 0.0)) * buf[2] + mat4(vec4(-2.4218085, -1.968602, -4.35166, 0.0), vec4(-22.683098, -18.0544, -41.954372, 0.0), vec4(0.63792, 0.5470648, 1.1078634, 0.0), vec4(-1.5489894, -1.3075932, -2.6444845, 0.0)) * buf[3] + mat4(vec4(-0.49252132, -0.39877754, -0.91366625, 0.0), vec4(0.95609266, 0.7923952, 1.640221, 0.0), vec4(0.30616966, 0.15693925, 0.8639857, 0.0), vec4(1.1825981, 0.94504964, 2.176963, 0.0)) * buf[4] + mat4(vec4(0.35446745, 0.3293795, 0.59547555, 0.0), vec4(-0.58784515, -0.48177817, -1.0614829, 0.0), vec4(2.5271258, 1.9991658, 4.6846647, 0.0), vec4(0.13042648, 0.08864098, 0.30187556, 0.0)) * buf[5] + mat4(vec4(-1.7718065, -1.4033192, -3.3355875, 0.0), vec4(3.1664357, 2.638297, 5.378702, 0.0), vec4(-3.1724713, -2.6107926, -5.549295, 0.0), vec4(-2.851368, -2.249092, -5.3013067, 0.0)) * buf[6] + mat4(vec4(1.5203838, 1.2212278, 2.8404984, 0.0), vec4(1.5210563, 1.2651345, 2.683903, 0.0), vec4(2.9789467, 2.4364579, 5.2347264, 0.0), vec4(2.2270417, 1.8825914, 3.8028636, 0.0)) * buf[7] + vec4(-1.5468478, -3.6171484, 0.24762098, 0.0);\n      buf[0] = sigmoid(buf[0]);\n      \n      return vec4(buf[0].x, buf[0].y, buf[0].z, 1.0);\n    }\n\n    void main() {\n      float t = uTime * uSpeed * uFoldSpeed * 0.5;\n      \n      vec2 dirOffset = vec2(1.0, 1.0);\n      if (uDirection == 1.0) dirOffset = vec2(0.0, 1.0);      // up\n      else if (uDirection == 2.0) dirOffset = vec2(0.0, -1.0); // down\n      else if (uDirection == 3.0) dirOffset = vec2(1.0, 0.0);\n      else if (uDirection == 4.0) dirOffset = vec2(-1.0, 0.0);\n      \n      vec2 uv = vUv * 2.0 - 1.0;\n      uv.y *= -1.0;\n      \n      uv += uDisplacement * 0.15;\n      \n      vec2 mouseUV = uMouse * 2.0 - 1.0;\n      mouseUV.y *= -1.0;\n      float mouseDist = distance(uv, mouseUV);\n      float mouseInfluence = smoothstep(uMouseRadius * 2.0, 0.0, mouseDist) * uReactiveStrength;\n      \n      float warpAmount = uFoldIntensity;\n      uv += warpAmount * vec2(sin(uv.y * 6.283 + t * 0.5 * dirOffset.y), cos(uv.x * 6.283 + t * 0.5 * dirOffset.x)) * 0.05;\n      \n      vec2 mouseOffset = (mouseUV - vec2(0.0)) * 0.5;\n      uv += mouseInfluence * mouseOffset * 0.15;\n      \n      if (uPulse > 0.01) {\n        vec2 clickUV = uLastClickPos * 2.0 - 1.0;\n        clickUV.y *= -1.0;\n        float clickDist = distance(uv, clickUV);\n        float expandProgress = 1.0 - uPulse;\n        float waveRadius = expandProgress * uMouseRadius * 4.0;\n        float waveThickness = uMouseRadius * 0.8;\n        float wave = smoothstep(waveRadius + waveThickness, waveRadius, clickDist) * \n                     smoothstep(waveRadius - waveThickness, waveRadius, clickDist);\n        float clickInfluence = wave * uPulse;\n        vec2 clickOffset = (clickUV - vec2(0.0)) * 0.4;\n        uv += clickInfluence * clickOffset * 0.5;\n      }\n      \n      uv *= uFoldScale;\n      \n      float scrollPhase = uScrollOffset * 0.15;\n      \n      uv.y += sin(scrollPhase) * 1.5 + sin(scrollPhase * 0.7) * 1.0;\n      uv.x += cos(scrollPhase * 0.6) * 0.8 + sin(scrollPhase * 0.4) * 0.5;\n      \n      vec2 dirFlow = vec2(t * 0.15 * dirOffset.x, t * 0.15 * dirOffset.y);\n      vec2 uvBase = uv + dirFlow;\n      \n      float tileSize = 4.0;\n      float blendZone = 0.8;\n      \n      vec2 uvWrapped = mod(uvBase + 100.0, tileSize);\n      vec2 edgeDist = min(uvWrapped, tileSize - uvWrapped);\n      vec2 blendWeight = smoothstep(0.0, blendZone, edgeDist);\n      float blend = blendWeight.x * blendWeight.y;\n      \n      vec2 uv1a = uvWrapped - tileSize * 0.5;\n      vec2 uv1b = uv1a + vec2(tileSize * 0.5);\n      \n      vec2 uv2 = uv + vec2(sin(scrollPhase * 0.3 + 2.0), cos(scrollPhase * 0.5 + 1.0)) * 1.5;\n      vec2 uv3 = uv + vec2(cos(scrollPhase * 0.4 + 3.0), sin(scrollPhase * 0.35 + 2.5)) * 2.0;\n      \n      vec4 cppn1a = cppn_fn(uv1a, 0.1 * sin(0.3 * t + scrollPhase * 0.1), 0.1 * sin(0.69 * t), 0.1 * sin(0.44 * t));\n      vec4 cppn1b = cppn_fn(uv1b, 0.1 * sin(0.3 * t + scrollPhase * 0.1), 0.1 * sin(0.69 * t), 0.1 * sin(0.44 * t));\n      vec4 cppn1 = mix(cppn1b, cppn1a, blend);\n      vec4 cppn2 = cppn_fn(uv2 * 0.7, 0.1 * sin(0.4 * t + 1.0), 0.1 * sin(0.5 * t + scrollPhase * 0.08), 0.1 * sin(0.35 * t));\n      vec4 cppn3 = cppn_fn(uv3 * 1.3, 0.1 * sin(0.25 * t + 2.0), 0.1 * sin(0.8 * t), 0.1 * sin(0.55 * t + scrollPhase * 0.12));\n      \n      vec3 cppnBlend = cppn1.rgb * 0.5 + cppn2.rgb * 0.3 + cppn3.rgb * 0.2;\n      \n      vec3 bgColor = uColors[0] * uColorBalance[0];\n      vec3 color1 = uColors[1] * uColorBalance[1];\n      vec3 color2 = uColors[2] * uColorBalance[2];\n      vec3 color3 = uColors[3] * uColorBalance[3];\n      \n      float blendSharpness = uColorBlend == 1.0 ? 0.15 : (uColorBlend == 2.0 ? 0.05 : 0.35);\n      \n      float w1 = cppnBlend.r;\n      float w2 = cppnBlend.g;\n      float w3 = cppnBlend.b;\n      \n      float sharpPow = blendSharpness < 0.1 ? 8.0 : (blendSharpness < 0.25 ? 3.0 : 1.0);\n      w1 = pow(w1, sharpPow);\n      w2 = pow(w2, sharpPow);\n      w3 = pow(w3, sharpPow);\n      \n      if (blendSharpness < 0.1) {\n        w1 = w1 > 0.3 ? 1.0 : 0.0;\n        w2 = w2 > 0.3 ? 1.0 : 0.0;\n        w3 = w3 > 0.3 ? 1.0 : 0.0;\n      }\n      \n      float lum = dot(cppnBlend, vec3(0.33));\n      \n      vec3 col = bgColor * (1.0 - lum * 0.8);\n      col += color1 * w1 * 0.6;\n      col += color2 * w2 * 0.5;\n      col += color3 * w3 * 0.4;\n      \n      col = mix(col, mix(color1, color2, cppn2.r), cppn2.g * 0.3);\n      \n      col += color2 * pow(lum, 2.0) * 0.3;\n      \n      float vignette = 1.0 - length(vUv - 0.5) * 0.3;\n      col *= vignette;\n      \n      if (uRimLight > 0.5) {\n        float cppnLum = dot(cppnBlend, vec3(0.33));\n        float rimThreshold = 0.3 - uRimFalloff * 0.05;\n        float rim = smoothstep(rimThreshold, rimThreshold + 0.25, cppnLum);\n        col += uRimColor * rim * uRimIntensity * 1.5;\n      }\n      \n      col += (rand(gl_FragCoord.xy + t) - 0.5) * uGrain;\n      \n      float alpha = 1.0;\n      if (uUseTextMask > 0.5) {\n        alpha = texture2D(uTextMask, vUv).a;\n      }\n      \n      gl_FragColor = vec4(clamp(col, 0.0, 1.0), alpha);\n    }\n  "}},x=new Set(["h1","h2","h3","h4","h5","h6","p","span","a","label","button","strong","b","em","i","u","s","strike","del","ins","mark","small","sub","sup","code","kbd","samp","var","cite","dfn","abbr","q","time","data","blockquote","pre","address","figcaption","li","dt","dd","th","td","caption","legend","option","summary","bdi","bdo","ruby","rt","rp","wbr"]);class b{constructor(){this.effects=new Map,this.targetElements=new Map,this.displayCanvases=new Map,this.textMasks=new Map,this.sharedRenderer=null,this.sharedPixelRatio=Math.min(window.devicePixelRatio,2),this.lastRenderedWidth=0,this.lastRenderedHeight=0,this.mouse=new THREE.Vector2(.5,.5),this.targetMouse=new THREE.Vector2(.5,.5),this.scrollY=window.scrollY,this.time=0,this.onMouseMove=this.onMouseMove.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onScroll=this.onScroll.bind(this),this.onVisibilityChange=this.onVisibilityChange.bind(this),document.addEventListener("mousemove",this.onMouseMove),document.addEventListener("mousedown",this.onMouseDown),document.addEventListener("touchstart",this.onTouchStart,{passive:!0}),document.addEventListener("touchmove",this.onTouchMove,{passive:!0}),window.addEventListener("scroll",this.onScroll,{passive:!0}),window.addEventListener("wheel",this.onWheel.bind(this),{passive:!0}),document.addEventListener("visibilitychange",this.onVisibilityChange),this.initSharedRenderer()}initSharedRenderer(){const n=e.getSupported();if(!n)return!1;const o=document.createElement("canvas"),t={alpha:!0,antialias:!v(),powerPreference:"high-performance",preserveDrawingBuffer:!v()};let i;return i="webgl2"===n?o.getContext("webgl2",t):o.getContext("webgl",t)||o.getContext("experimental-webgl",t),!!i&&(this.sharedRenderer=new THREE.WebGLRenderer({canvas:o,context:i,antialias:!v(),alpha:!0,powerPreference:"high-performance"}),this.sharedRenderer.setPixelRatio(this.sharedPixelRatio),this.sharedRenderer.setClearColor(0,0),this.sharedRenderer.autoClear=!0,!0)}createMesh(e){const n=g[e.mode];if(!n)return console.error(`spectraGL: Unknown mode "${e.mode}"`),null;let o=Math.min(e.meshDetail,128);if(v()){["nebula","oil","floral"].includes(e.mode)&&(o=Math.max(8,Math.floor(.5*o)))}const t=new THREE.PlaneGeometry(2,2,o,o),i=[...e.colors];for(;i.length<7;)i.push(i[i.length-1]||"#ffffff");const l=e.colorBalance||[],a=[];for(let e=0;e<7;e++)a.push(void 0!==l[e]?l[e]:1);const s={smooth:0,sharp:1,stepped:2}[e.colorBlend]||0,r={auto:0,up:1,down:2,left:3,right:4}[e.direction]||0,c=new THREE.ShaderMaterial({uniforms:{uTime:{value:0},uMouse:{value:new THREE.Vector2(.5,.5)},uMouseVelocity:{value:new THREE.Vector2(0,0)},uDisplacement:{value:new THREE.Vector2(0,0)},uClickOffset:{value:0},uLastClickPos:{value:new THREE.Vector2(.5,.5)},uPulse:{value:0},uResolution:{value:new THREE.Vector2(1,1)},uColors:{value:i.slice(0,7).map(e=>new THREE.Color(e))},uColorBlend:{value:s},uColorBalance:{value:a},uDirection:{value:r},uSpeed:{value:e.speed},uTextMask:{value:null},uUseTextMask:{value:0},uFoldIntensity:{value:e.foldIntensity},uFoldScale:{value:e.foldScale},uFoldSpeed:{value:e.foldSpeed},uRimLight:{value:e.rimLight?1:0},uRimIntensity:{value:e.rimIntensity},uRimColor:{value:new THREE.Color(e.rimColor)},uRimFalloff:{value:e.rimFalloff},uGrain:{value:e.grain},uReactiveStrength:{value:e.reactive?e.reactiveStrength:0},uMouseRadius:{value:e.mouseRadius},uScrollOffset:{value:0},uScrollVelocity:{value:0}},vertexShader:n.vertex,fragmentShader:n.fragment,transparent:!0,side:THREE.DoubleSide});return new THREE.Mesh(t,c)}addEffect(e,n,o){if(!this.sharedRenderer)return this.applyFallback(n,o),!1;const t=function(e){const n=e.tagName.toLowerCase();return x.has(n)}(n)&&!o.border?.enabled;t&&(o._isTextElement=!0);const i=this.createMesh(o);if(!i)return!1;const l=new THREE.Scene,a=new THREE.OrthographicCamera(-1,1,1,-1,-100,100);a.position.z=10,l.add(i);const s=function(e){let n=0,o=!1,t=e;for(;t&&t!==document.body;){const e=window.getComputedStyle(t),i=e.position,l=parseInt(e.zIndex,10);"fixed"===i&&(o=!0),"static"===i||isNaN(l)||(n=Math.max(n,l)),t=t.parentElement}const i=window.getComputedStyle(e),l=parseInt(i.zIndex,10);"static"===i.position||isNaN(l)||(n=Math.max(n,l));return{position:o?"fixed":"absolute",zIndex:n,isFixedContext:o}}(n),r=document.createElement("canvas");r.setAttribute("data-spectra-id",e);const c=r.getContext("2d",{alpha:!0});if(s.isFixedContext?document.body.appendChild(r):n.parentNode.insertBefore(r,n),this.displayCanvases.set(e,{canvas:r,ctx:c,lastWidth:0,lastHeight:0}),this.effects.set(e,{mesh:i,scene:l,camera:a,element:n,options:o,inView:!0,observer:null,originalVisibility:n.style.visibility,currentMouse:new THREE.Vector2(.5,.5),prevMouse:new THREE.Vector2(.5,.5),mouseVelocity:new THREE.Vector2(0,0),displacement:new THREE.Vector2(0,0),pulse:0,clickOffset:0,clickOffsetTarget:0,lastClickPos:new THREE.Vector2(.5,.5),scrollOffset:0,scrollVelocity:0,stacking:s,useTextMask:t}),t&&this.updateTextMask(e,n,i),this.targetElements.set(e,n),"IntersectionObserver"in window){const o=new IntersectionObserver(n=>{const o=this.effects.get(e);o&&(o.inView=n[0].isIntersecting)},{root:null,threshold:0,rootMargin:"200px"});o.observe(n),this.effects.get(e).observer=o}if(!o.border||!o.border.enabled)if(t)setTimeout(()=>{n.style.color="transparent"},16);else{const e=n.parentNode;if(e&&e!==document.body){const n=window.getComputedStyle(e),o=n.transform&&"none"!==n.transform,t=n.filter&&"none"!==n.filter;"isolate"===n.isolation||"auto"!==n.zIndex||o||t||"1"!==n.opacity||(e.style.isolation="isolate")}setTimeout(()=>{n.style.visibility="hidden"},16)}return!0}updateTextMask(e,n,o){const t=n.getBoundingClientRect();if(t.width<=0||t.height<=0){const n=this.effects.get(e);return void(n&&(n.needsTextMask=!0))}const i=function(e,n,o){const t=document.createElement("canvas"),i=t.getContext("2d"),l=Math.min(window.devicePixelRatio,2);t.width=n*l,t.height=o*l,i.clearRect(0,0,t.width,t.height);const a=window.getComputedStyle(e),s=parseFloat(a.fontSize),r=a.fontFamily,c=a.fontWeight,u=a.fontStyle,f=a.lineHeight,d=parseFloat(a.paddingLeft)||0,m=parseFloat(a.paddingTop)||0,v=s*l;i.font=`${u} ${c} ${v}px ${r}`,i.fillStyle="#ffffff",i.textBaseline="top",i.textAlign="left";const p=(e.textContent||"").trim(),h=d*l;let g;const x=parseFloat(f);return g=isNaN(x)?m*l:(x-s)/2*l+m*l,i.fillText(p,h,g),t}(n,t.width,t.height),l=new THREE.CanvasTexture(i);l.needsUpdate=!0,l.minFilter=THREE.LinearFilter,l.magFilter=THREE.LinearFilter,l.format=THREE.RGBAFormat,l.premultiplyAlpha=!1;const a=this.textMasks.get(e);a&&a.dispose(),this.textMasks.set(e,l),o&&o.material&&o.material.uniforms&&(o.material.uniforms.uTextMask.value=l,o.material.uniforms.uUseTextMask.value=1,o.material.needsUpdate=!0)}applyFallback(e,n){const o=`linear-gradient(135deg, ${n.colors.slice(0,3).join(", ")})`;e.style.background=o,e.setAttribute("data-spectra-fallback","true")}removeEffect(e,n=!1){const o=this.effects.get(e);if(o){n||(o.element.style.visibility=o.originalVisibility||"");const t=this.displayCanvases.get(e);t&&t.canvas&&t.canvas.remove(),this.displayCanvases.delete(e),o.mesh&&(o.mesh.geometry&&o.mesh.geometry.dispose(),o.mesh.material&&o.mesh.material.dispose());const i=this.textMasks.get(e);i&&(i.dispose(),this.textMasks.delete(e)),o.observer&&o.observer.disconnect(),this.effects.delete(e),this.targetElements.delete(e)}}onMouseMove(e){for(const[n,o]of this.effects){if(!o.options.reactive)continue;const n=o.element.getBoundingClientRect();if(e.clientX>=n.left&&e.clientX<=n.right&&e.clientY>=n.top&&e.clientY<=n.bottom){const t=(e.clientX-n.left)/n.width,i=1-(e.clientY-n.top)/n.height;o.currentMouse.set(t,i)}}}onMouseDown(e){for(const[n,o]of this.effects){const n=o.element.getBoundingClientRect();if(e.clientX>=n.left&&e.clientX<=n.right&&e.clientY>=n.top&&e.clientY<=n.bottom&&o.options.reactive){o.pulse=1;const t=(e.clientX-n.left)/n.width,i=1-(e.clientY-n.top)/n.height;o.lastClickPos=new THREE.Vector2(t,i),"aurora"===o.options.mode&&(o.clickOffsetTarget=(o.clickOffsetTarget||0)+.6)}}}onTouchStart(e){if(e.touches.length>0){const n=e.touches[0];for(const[e,o]of this.effects){const e=o.element.getBoundingClientRect();if(n.clientX>=e.left&&n.clientX<=e.right&&n.clientY>=e.top&&n.clientY<=e.bottom&&(o.lastTouchY=n.clientY,o.options.reactive)){const t=(n.clientX-e.left)/e.width,i=1-(n.clientY-e.top)/e.height;o.currentMouse.set(t,i),o.pulse=1,"aurora"===o.options.mode&&(o.clickOffsetTarget=(o.clickOffsetTarget||0)+.6,o.lastClickPos=new THREE.Vector2(t,i))}}}}onTouchMove(e){if(e.touches.length>0){const n=e.touches[0];for(const[e,o]of this.effects){const e=o.element.getBoundingClientRect();if(n.clientX>=e.left&&n.clientX<=e.right&&n.clientY>=e.top&&n.clientY<=e.bottom){if(o.options.scrollReactive&&void 0!==o.lastTouchY){const e=o.lastTouchY-n.clientY,t=o.options.scrollStrength||.2;o.scrollVelocity-=.003*e*t,o.lastTouchY=n.clientY}if(o.options.reactive){const t=(n.clientX-e.left)/e.width,i=1-(n.clientY-e.top)/e.height;o.currentMouse.set(t,i)}}}}}onScroll(){this.scrollY=window.scrollY}onWheel(e){for(const[n,o]of this.effects){if(!o.options.scrollReactive)continue;const n=o.element.getBoundingClientRect();if(e.clientX>=n.left&&e.clientX<=n.right&&e.clientY>=n.top&&e.clientY<=n.bottom){const n=o.options.scrollStrength||.2;o.scrollVelocity-=8e-4*e.deltaY*n}}}onVisibilityChange(){u=!document.hidden}animate(){if(!l)return;if(!this.sharedRenderer)return void(i=requestAnimationFrame(()=>this.animate()));if(!u)return void(i=requestAnimationFrame(()=>this.animate()));const e=performance.now(),n=e-r;if(n<c)i=requestAnimationFrame(()=>this.animate());else{r=e-n%c,this.time+=Math.min(n/1e3,.1);for(const[n,o]of this.effects){if(!o.inView)continue;const{mesh:t,scene:i,camera:l,options:a,element:s}=o,r=this.displayCanvases.get(n);if(!r)continue;const{canvas:c,ctx:u}=r;(!o.cachedRect||o.rectCacheTime<e-100)&&(o.cachedRect=s.getBoundingClientRect(),o.rectCacheTime=e);const f=o.cachedRect;if(f.width<=1||f.height<=1)continue;o.needsTextMask&&o.useTextMask&&(this.updateTextMask(n,s,t),o.needsTextMask=!1);const d=o.currentMouse.x-o.prevMouse.x,m=o.currentMouse.y-o.prevMouse.y;if(o.mouseVelocity.set(d,m),o.prevMouse.copy(o.currentMouse),a.reactive){const e=26.67*(void 0!==a.displacementStrength?a.displacementStrength:.3);o.displacement.x+=d*e,o.displacement.y+=m*e,o.displacement.x*=.992,o.displacement.y*=.992}if(o.pulse>0){let e=.96;"komorebi"===o.options.mode&&(e=.99),o.pulse*=e,o.pulse<.01&&(o.pulse=0)}"aurora"===o.options.mode&&(o.clickOffset+=.08*(o.clickOffsetTarget-o.clickOffset));const v=.88+.06*(a.scrollStrength||.2);o.scrollOffset+=o.scrollVelocity,o.scrollVelocity*=v;const p=t.material.uniforms;p.uTime.value=this.time,p.uMouse.value.lerp(o.currentMouse,.1),p.uMouseVelocity?.value.copy(o.mouseVelocity),p.uDisplacement?.value.copy(o.displacement),p.uPulse&&(p.uPulse.value=o.pulse),p.uClickOffset&&(p.uClickOffset.value=o.clickOffset||0),p.uLastClickPos&&(p.uLastClickPos.value=o.lastClickPos||new THREE.Vector2(.5,.5)),p.uScrollOffset&&(p.uScrollOffset.value=o.scrollOffset),p.uScrollVelocity&&(p.uScrollVelocity.value=100*Math.abs(o.scrollVelocity));const h=o.stacking;(!o.cachedStyle||o.styleCacheTime<e-500)&&(o.cachedStyle=window.getComputedStyle(s),o.styleCacheTime=e);const g=o.cachedStyle;let x,b;if(a.border&&a.border.enabled){const e=a.border.width||2;x=f.width+2*e,b=f.height+2*e}else x=f.width,b=f.height;const y=Math.floor(x*this.sharedPixelRatio),w=Math.floor(b*this.sharedPixelRatio);y===this.lastRenderedWidth&&w===this.lastRenderedHeight||(this.sharedRenderer.setSize(x,b),this.lastRenderedWidth=y,this.lastRenderedHeight=w);const C=r.lastWidth!==y||r.lastHeight!==w;if(C&&(c.width=y,c.height=w,r.lastWidth=y,r.lastHeight=w),p.uResolution.value.set(y,w),this.sharedRenderer.render(i,l),C&&u.clearRect(0,0,y,w),u.drawImage(this.sharedRenderer.domElement,0,0,y,w),c.style.position=h.position,c.style.display="block",c.style.visibility="visible",c.style.pointerEvents="none",c.style.willChange="transform",c.style.width=`${x}px`,c.style.height=`${b}px`,"fixed"===h.position)c.style.top=`${f.top}px`,c.style.left=`${f.left}px`,c.style.zIndex=String(h.zIndex+1);else{c.style.top=`${s.offsetTop}px`,c.style.left=`${s.offsetLeft}px`;const e=window.getComputedStyle(s);c.style.zIndex="auto"===e.zIndex?"0":e.zIndex}if(a.border&&a.border.enabled){const e=a.border.width||2,n=s.parentNode;n.style.overflow="visible",n.style.position="relative",n.style.zIndex="0",c.style.top=`-${e}px`,c.style.left=`-${e}px`,c.style.zIndex="-1";const o=window.getComputedStyle(n);let t=parseFloat(o.borderRadius)||0;a.border.radius&&(t=a.border.radius);const i=t+e;c.style.borderRadius=`${i}px`,c.style.overflow="hidden";const l=e,r=x,u=b,d=f.width,m=f.height,v=`url("data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${r}" height="${u}"><path fill-rule="evenodd" fill="white" d="M${i},0 H${r-i} A${i},${i} 0 0 1 ${r},${i} V${u-i} A${i},${i} 0 0 1 ${r-i},${u} H${i} A${i},${i} 0 0 1 0,${u-i} V${i} A${i},${i} 0 0 1 ${i},0 Z M${l+t},${l} A${t},${t} 0 0 0 ${l},${l+t} V${l+m-t} A${t},${t} 0 0 0 ${l+t},${l+m} H${l+d-t} A${t},${t} 0 0 0 ${l+d},${l+m-t} V${l+t} A${t},${t} 0 0 0 ${l+d-t},${l} Z"/></svg>`)}")`;c.style.maskImage=v,c.style.webkitMaskImage=v,c.style.maskSize="100% 100%",c.style.webkitMaskSize="100% 100%"}else c.style.borderRadius!==g.borderRadius&&(c.style.borderRadius=g.borderRadius),c.style.overflow="hidden",c.style.maskImage="none",c.style.webkitMaskImage="none"}i=requestAnimationFrame(()=>this.animate())}}startAnimation(){l||(l=!0,this.animate())}stopAnimation(){l&&(l=!1,i&&(cancelAnimationFrame(i),i=null))}dispose(){this.stopAnimation();for(const[e]of this.effects)this.removeEffect(e);document.removeEventListener("mousemove",this.onMouseMove),document.removeEventListener("mousedown",this.onMouseDown),document.removeEventListener("touchstart",this.onTouchStart),document.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("scroll",this.onScroll),document.removeEventListener("visibilitychange",this.onVisibilityChange),this.sharedRenderer&&(this.sharedRenderer.dispose(),this.sharedRenderer=null),this.effects.clear(),this.targetElements.clear(),this.displayCanvases.clear()}}class y{constructor(n,t){this.id="spectra-"+ ++o,this.options=n,this.elements=t,this.initialized=!1,this.paused=!1,this.supported=e.getSupported(),this.fallbackApplied=!1,this.helperGUI=null}init(){if(!this.initialized){n||(n=new b,n.startAnimation(),function(){if(a)return;let e=window.innerWidth,n=window.innerHeight;const o=()=>{s&&clearTimeout(s),s=setTimeout(()=>{const o=Math.abs(window.innerWidth-e)>10,i=Math.abs(window.innerHeight-n)>100;if(o||i){for(const[,e]of t)e&&e.initialized&&(e.destroy(),setTimeout(()=>e.init(),50));e=window.innerWidth,n=window.innerHeight}},250)};window.addEventListener("resize",o),a={handleResize:o}}());for(let e=0;e<this.elements.length;e++){const o=this.elements[e],t=o.id||`el-${e}`,i=`${this.id}-${t}`;n.addEffect(i,o,this.options)||(this.fallbackApplied=!0)}this.initialized=!0,t.set(this.id,this),this.options.helper&&function(){if(d)return Promise.resolve();if(m)return m;return m=new Promise((e,n)=>{if("undefined"!=typeof lil)return d=!0,void e();const o=document.createElement("script");o.src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js",o.integrity="sha384-2eNPNc7Cms+nVcpmQPotBpthLWCwjAGbkp0Y+3MUQqwPbmTpMFmbh2a230Gkns0x",o.crossOrigin="anonymous",o.onload=()=>{d=!0,function(){if(document.getElementById("spectragl-helper-styles"))return;const e=document.createElement("style");e.id="spectragl-helper-styles",e.textContent='\n      @media screen and (max-width: 768px) {\n        .lil-gui.root.spectragl-helper {\n          width: 61vw;\n        }\n      }\n\n      .lil-gui.root.spectragl-helper {\n        --background-color: rgb(9 9 11 / 85%);\n        --widget-color: rgb(39 39 42 / 50%);\n        --hover-color: rgb(39 39 42 / 70%);\n        --focus-color: rgb(39 39 42 / 90%);\n        --number-color: #fafafa;\n        --string-color: #fafafa;\n        --font-size: 13px;\n        --input-font-size: 13px;\n        --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n        --font-family-mono: monospace;\n        --padding: 10px;\n        --spacing: 10px;\n        --widget-height: 28px;\n        --title-height: 28px;\n        --name-width: 45%;\n        --slider-knob-width: 4px;\n        --slider-input-width: 27%;\n        --color-input-width: 27%;\n        --slider-input-min-width: 45px;\n        --color-input-min-width: 45px;\n        --folder-indent: 8px;\n        --widget-padding: 0 10px;\n        --widget-border-radius: 4px;\n        --checkbox-size: 16px;\n        --scrollbar-width: 6px;\n        border-radius: 12px !important;\n        border: 0.5px solid #1e1e20 !important;\n        backdrop-filter: blur(16px);\n        box-shadow: 0 4px 16px rgb(0 0 0 / 20%) !important;\n        position: fixed !important;\n        top: 1rem !important;\n        right: 1rem !important;\n        left: auto !important;\n        z-index: 999999999 !important;\n      }\n\n      .lil-gui.spectragl-helper .title {\n        background: transparent;\n        border-bottom: 0.5px solid #1e1e20;\n        border-radius: 12px 12px 0 0 !important;\n      }\n\n      .lil-gui.spectragl-helper .title button {\n        padding: 12px 16px !important;\n      }\n\n      .lil-gui.spectragl-helper.closed .title {\n        border-radius: 12px !important;\n        border-bottom: none;\n      }\n\n      .lil-gui.spectragl-helper .children {\n        border-top: 0.5px solid #1e1e20;\n      }\n\n      @media (max-width: 768px) {\n        .lil-gui.root.spectragl-helper {\n          top: 1rem !important;\n          right: 1rem !important;\n        }\n      }\n    ',document.head.appendChild(e)}(),e()},o.onerror=()=>{n(new Error("Failed to load lil-gui"))},document.head.appendChild(o)}),m}().then(()=>{const e=f.length;this.helperGUI=function(e,n){if("undefined"==typeof lil)return;const o=new lil.GUI({title:`spectraGL Helper ${n+1}`,closeFolders:!0});o.domElement.classList.add("spectragl-helper"),o.$title.style.cursor="default";const t=1+3*n;o.domElement.style.top=`${t}rem`;const i=e.options,l={color1:i.colors[0]||"#ff6b6b",color2:i.colors[1]||"#4ecdc4",color3:i.colors[2]||"#45b7d1",color4:i.colors[3]||"#f9ca24",color5:i.colors[4]||"#6c5ce7",color6:i.colors[5]||"#00b894",color7:i.colors[6]||"#fd79a8",rimColor:i.rimColor||"#ffffff",colorBlend:i.colorBlend||"smooth",balance1:i.colorBalance[0]||1,balance2:i.colorBalance[1]||1,balance3:i.colorBalance[2]||1,balance4:i.colorBalance[3]||1,balance5:i.colorBalance[4]||1,balance6:i.colorBalance[5]||1,balance7:i.colorBalance[6]||1},a=()=>{e.updateOptions({colors:[l.color1,l.color2,l.color3,l.color4,l.color5,l.color6,l.color7]})},s=()=>{e.updateOptions({colorBalance:[l.balance1,l.balance2,l.balance3,l.balance4,l.balance5,l.balance6,l.balance7]})},r=o.addFolder("Colors");r.addColor(l,"color1").name("Color 1").onChange(a),r.addColor(l,"color2").name("Color 2").onChange(a),r.addColor(l,"color3").name("Color 3").onChange(a),r.addColor(l,"color4").name("Color 4").onChange(a),r.addColor(l,"color5").name("Color 5").onChange(a),r.addColor(l,"color6").name("Color 6").onChange(a),r.addColor(l,"color7").name("Color 7").onChange(a),r.addColor(l,"rimColor").name("Rim Color").onChange(n=>{e.updateOptions({rimColor:n})}),r.add(l,"colorBlend",["smooth","sharp","stepped"]).name("Blend Mode").onChange(n=>{e.updateOptions({colorBlend:n})}),r.add(l,"balance1",0,2,.1).name("Balance 1").onChange(s),r.add(l,"balance2",0,2,.1).name("Balance 2").onChange(s),r.add(l,"balance3",0,2,.1).name("Balance 3").onChange(s),r.add(l,"balance4",0,2,.1).name("Balance 4").onChange(s),r.add(l,"balance5",0,2,.1).name("Balance 5").onChange(s),r.add(l,"balance6",0,2,.1).name("Balance 6").onChange(s),r.add(l,"balance7",0,2,.1).name("Balance 7").onChange(s);const c=o.addFolder("Animation"),u={speed:i.speed||1,foldSpeed:i.foldSpeed||1,direction:i.direction||"auto"};c.add(u,"speed",0,5,.1).name("Speed").onChange(n=>{e.updateOptions({speed:n})}),c.add(u,"foldSpeed",0,5,.1).name("Fold Speed").onChange(n=>{e.updateOptions({foldSpeed:n})}),c.add(u,"direction",["auto","up","down","left","right"]).name("Direction").onChange(n=>{e.updateOptions({direction:n})});const d=o.addFolder("Geometry"),m={foldIntensity:i.foldIntensity||.5,foldScale:i.foldScale||1};d.add(m,"foldIntensity",0,2,.05).name("Fold Intensity").onChange(n=>{e.updateOptions({foldIntensity:n})}),d.add(m,"foldScale",0,5,.1).name("Fold Scale").onChange(n=>{e.updateOptions({foldScale:n})});const v=o.addFolder("Lighting"),p={rimLight:void 0===i.rimLight||i.rimLight,rimIntensity:i.rimIntensity||.8,rimFalloff:i.rimFalloff||2,grain:i.grain||.05};v.add(p,"rimLight").name("Rim Light").onChange(n=>{e.updateOptions({rimLight:n})}),v.add(p,"rimIntensity",0,1,.05).name("Rim Intensity").onChange(n=>{e.updateOptions({rimIntensity:n})}),v.add(p,"rimFalloff",.5,5,.1).name("Rim Falloff").onChange(n=>{e.updateOptions({rimFalloff:n})}),v.add(p,"grain",0,.3,.01).name("Grain").onChange(n=>{e.updateOptions({grain:n})});const h=o.addFolder("Interaction"),g={reactive:void 0===i.reactive||i.reactive,reactiveStrength:i.reactiveStrength||.3,displacementStrength:i.displacementStrength||.3,mouseRadius:i.mouseRadius||.15,scrollReactive:void 0!==i.scrollReactive&&i.scrollReactive,scrollStrength:i.scrollStrength||.2};h.add(g,"reactive").name("Reactive").onChange(n=>{e.updateOptions({reactive:n})}),h.add(g,"reactiveStrength",0,2,.05).name("Reactive Strength").onChange(n=>{e.updateOptions({reactiveStrength:n})}),h.add(g,"displacementStrength",0,2,.05).name("Displacement Strength").onChange(n=>{e.updateOptions({displacementStrength:n})}),h.add(g,"mouseRadius",0,1,.05).name("Mouse Radius").onChange(n=>{e.updateOptions({mouseRadius:n})}),h.add(g,"scrollReactive").name("Scroll Reactive").onChange(n=>{e.updateOptions({scrollReactive:n})}),h.add(g,"scrollStrength",0,2,.05).name("Scroll Strength").onChange(n=>{e.updateOptions({scrollStrength:n})});const x=o.addFolder("Border"),b={enabled:i.border.enabled||!1,width:i.border.width||2,radius:i.border.radius||0};x.add(b,"enabled").name("Enabled").onChange(n=>{e.updateOptions({border:{...i.border,enabled:n}})}),x.add(b,"width",1,20,1).name("Width").onChange(n=>{e.updateOptions({border:{...i.border,width:n}})}),x.add(b,"radius",0,50,1).name("Radius").onChange(n=>{e.updateOptions({border:{...i.border,radius:n}})});const y={mode:i.mode||"aurora",meshDetail:i.meshDetail||32,target:i.target||".spectraGL"};o.add(y,"mode",["aurora","shimmer","pixel","komorebi","nebula","floral","oil","diva"]).name("Mode").onFinishChange(n=>{confirm("Changing mode requires reinitialization. Continue?")?e.updateOptions({mode:n}):(y.mode=i.mode,o.controllersRecursive().forEach(e=>e.updateDisplay()))}),o.add(y,"meshDetail",16,128,1).name("Mesh Detail").onFinishChange(n=>{confirm("Changing mesh detail requires reinitialization. Continue?")?e.updateOptions({meshDetail:n}):(y.meshDetail=i.meshDetail,o.controllersRecursive().forEach(e=>e.updateDisplay()))});const w={qualityPreset:i.qualityPreset||"balanced",pixelRatio:i.pixelRatio||"auto",maxFPS:i.maxFPS||60};o.add(w,"qualityPreset",["low","balanced","high"]).name("Quality Preset").onChange(n=>{e.updateOptions({qualityPreset:n})}),o.add(w,"pixelRatio",["auto","1","2"]).name("Pixel Ratio").onChange(n=>{e.updateOptions({pixelRatio:"auto"===n?"auto":parseFloat(n)})}),o.add(w,"maxFPS",15,120,1).name("Max FPS").onChange(n=>{e.updateOptions({maxFPS:n})});const C={copySettings:()=>{const n=function(e){const n=["spectraGL({"];n.push(`  target: "${e.target}",`),n.push(`  mode: "${e.mode}",`);const o=e.colors.map(e=>`"${e}"`).join(", ");n.push(`  colors: [${o}],`),n.push(`  colorBlend: "${e.colorBlend}",`);const t=e.colorBalance.join(", ");return n.push(`  colorBalance: [${t}],`),n.push(`  meshDetail: ${e.meshDetail},`),n.push(`  foldIntensity: ${e.foldIntensity},`),n.push(`  foldScale: ${e.foldScale},`),n.push(`  foldSpeed: ${e.foldSpeed},`),n.push(`  rimLight: ${e.rimLight},`),n.push(`  rimIntensity: ${e.rimIntensity},`),n.push(`  rimColor: "${e.rimColor}",`),n.push(`  rimFalloff: ${e.rimFalloff},`),n.push(`  speed: ${e.speed},`),n.push(`  direction: "${e.direction}",`),n.push(`  grain: ${e.grain},`),n.push(`  reactive: ${e.reactive},`),n.push(`  reactiveStrength: ${e.reactiveStrength},`),n.push(`  displacementStrength: ${e.displacementStrength},`),n.push(`  mouseRadius: ${e.mouseRadius},`),n.push(`  scrollReactive: ${e.scrollReactive},`),n.push(`  scrollStrength: ${e.scrollStrength},`),n.push(`  pixelRatio: "${e.pixelRatio}",`),n.push(`  maxFPS: ${e.maxFPS},`),n.push(`  qualityPreset: "${e.qualityPreset}",`),n.push("  border: {"),n.push(`    enabled: ${e.border.enabled},`),n.push(`    width: ${e.border.width},`),n.push(`    radiusFromElement: ${e.border.radiusFromElement},`),n.push(`    radius: ${e.border.radius},`),n.push(`    position: "${e.border.position}",`),n.push("  },"),n.push("  helper: false,"),n.push("});"),n.join("\n")}(e.options),t=o.controllers.find(e=>"copySettings"===e.property);if(!t)return;const i=t._name;t.disable(),t.name(" Copied");const l=()=>{setTimeout(()=>{t.name(i),t.enable()},1500)};function a(e){const n=document.createElement("textarea");n.value=e,n.style.position="fixed",n.style.opacity="0",document.body.appendChild(n),n.select();try{document.execCommand("copy"),l()}catch(n){console.error("Copy failed:",n),t.name(i),t.enable(),prompt("Copy this code manually:",e)}document.body.removeChild(n)}navigator.clipboard&&navigator.clipboard.writeText?navigator.clipboard.writeText(n).then(()=>{l()}).catch(e=>{console.error("Clipboard error:",e),a(n)}):a(n)}};return o.add(C,"copySettings").name("Copy settings"),r.close(),c.close(),d.close(),v.close(),h.close(),x.close(),f.push({gui:o,instance:e}),o}(this,e)}).catch(e=>{console.error("Failed to load helper GUI:",e)}),this.options.on&&this.options.on.init&&this.options.on.init(this)}}destroy(){if(this.initialized){this.helperGUI&&(!function(e){const n=f.findIndex(n=>n.instance===e);if(-1!==n){const{gui:e}=f[n];e.destroy(),f.splice(n,1),f.forEach((e,n)=>{const o=1+3*n;e.gui.domElement.style.top=`${o}rem`})}}(this),this.helperGUI=null);for(let e=0;e<this.elements.length;e++){const o=this.elements[e].id||`el-${e}`,t=`${this.id}-${o}`;n.removeEffect(t)}t.delete(this.id),0===t.size&&n&&(n.dispose(),n=null,function(){a&&(window.removeEventListener("resize",a.handleResize),a=null);s&&(clearTimeout(s),s=null)}()),this.initialized=!1,this.options.on&&this.options.on.destroy&&this.options.on.destroy(this)}}pause(){this.paused=!0}play(){this.paused=!1}updateOptions(e){const n={...this.options};this.options={...this.options,...e};["target","mode","meshDetail"].some(o=>void 0!==e[o]&&e[o]!==n[o])?(this.destroy(),setTimeout(()=>this.init(),50)):this.updateLiveUniforms(e)}updateLiveUniforms(e){if(n)for(let o=0;o<this.elements.length;o++){const t=this.elements[o].id||`el-${o}`,i=`${this.id}-${t}`,l=n.effects.get(i);if(l&&l.mesh.material.uniforms){const n=l.mesh.material.uniforms;if(void 0!==e.speed&&(n.uSpeed.value=e.speed),void 0!==e.foldIntensity&&(n.uFoldIntensity.value=e.foldIntensity),void 0!==e.foldScale&&(n.uFoldScale.value=e.foldScale),void 0!==e.foldSpeed&&(n.uFoldSpeed.value=e.foldSpeed),void 0!==e.rimIntensity&&(n.uRimIntensity.value=e.rimIntensity),void 0!==e.rimColor&&n.uRimColor.value&&n.uRimColor.value.set(e.rimColor),void 0!==e.rimFalloff&&(n.uRimFalloff.value=e.rimFalloff),void 0!==e.grain&&(n.uGrain.value=e.grain),void 0!==e.reactiveStrength&&(n.uReactiveStrength.value=e.reactiveStrength),void 0!==e.displacementStrength&&(l.options.displacementStrength=e.displacementStrength),void 0!==e.mouseRadius&&(n.uMouseRadius.value=e.mouseRadius),void 0!==e.colors&&n.uColors.value){const o=e.colors,t=n.uColors.value;for(let e=0;e<7;e++)if(t[e]){const n=void 0!==o[e]?o[e]:o.length>0?o[o.length-1]:"#ffffff";t[e].set(n)}}if(void 0!==e.colorBlend){const o={smooth:0,sharp:1,stepped:2};n.uColorBlend.value=o[e.colorBlend]||0}if(void 0!==e.colorBalance){const o=e.colorBalance||[],t=[];for(let e=0;e<7;e++)t.push(void 0!==o[e]?o[e]:1);n.uColorBalance.value=t}if(void 0!==e.direction){const o={auto:0,up:1,down:2,left:3,right:4};n.uDirection.value=o[e.direction]||0}void 0!==e.rimLight&&(n.uRimLight.value=e.rimLight?1:0),l.options={...l.options,...e}}}}}window.spectraGL=function(e={}){const n={target:".spectraGL",mode:"aurora",colors:["#ff6b6b","#4ecdc4","#45b7d1","#f9ca24","#6c5ce7","#00b894","#fd79a8"],colorBlend:"smooth",colorBalance:[1,1,1,1,1,1,1],meshDetail:32,foldIntensity:.5,foldScale:1,foldSpeed:1,rimLight:!0,rimIntensity:.8,rimColor:"#ffffff",rimFalloff:2,speed:1,direction:"auto",grain:.05,reactive:!0,reactiveStrength:.3,displacementStrength:.3,mouseRadius:.15,scrollReactive:!1,scrollStrength:.2,pixelRatio:"auto",maxFPS:60,qualityPreset:"balanced",border:{enabled:!1,width:2,radiusFromElement:!0,radius:null,position:"outside"},on:{},helper:!1},o={...n,...e,border:{...n.border,...e.border||{}},on:{...n.on,...e.on||{}}};if(!e.qualityPreset&&function(){const e=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),n=navigator.hardwareConcurrency||2,o=navigator.deviceMemory||4;return e||n<=2||o<=2||v()}()&&(o.qualityPreset="low"),o.qualityPreset&&!e.meshDetail){const n={low:{meshDetail:16,maxFPS:30},balanced:{meshDetail:32,maxFPS:60},high:{meshDetail:64,maxFPS:60}}[o.qualityPreset];n&&(o.meshDetail=n.meshDetail,e.maxFPS||(o.maxFPS=n.maxFPS))}let t=o.maxFPS||60;if(v()&&!e.maxFPS){const e=["nebula","oil","floral"];Array.from(document.querySelectorAll(o.target)).some(n=>{const t=o.mode||"aurora";return e.includes(t)})&&(t=30)}c=1e3/t;const i=document.querySelectorAll(o.target);if(0===i.length)return console.error(`spectraGL: No elements found for "${o.target}"`),null;const l=new y(o,Array.from(i));return l.init(),{pause:()=>l.pause(),play:()=>l.play(),destroy:()=>l.destroy(),updateOptions:e=>l.updateOptions(e),get isPlaying(){return!l.paused},get options(){return l.options},get supported(){return l.supported},get fallbackApplied(){return l.fallbackApplied}}},window.spectraGL.isSupported=()=>e.getSupported(),window.spectraGL.version="1.0.0"}();